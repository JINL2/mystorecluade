import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

// Company service provider
final companyServiceProvider = Provider<CompanyService>((ref) {
  return CompanyService();
});

// Company types provider
final companyTypesProvider = FutureProvider<List<CompanyType>>((ref) async {
  final service = ref.read(companyServiceProvider);
  return service.getCompanyTypes();
});

// Currencies provider
final currenciesProvider = FutureProvider<List<Currency>>((ref) async {
  final service = ref.read(companyServiceProvider);
  return service.getCurrencies();
});

class CompanyService {
  final _supabase = Supabase.instance.client;

  /// Get all company types
  Future<List<CompanyType>> getCompanyTypes() async {
    try {
      final response = await _supabase
          .from('company_types')
          .select('*')
          .order('type_name');
      
      return (response as List)
          .map((json) => CompanyType.fromJson(json))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get all currencies
  Future<List<Currency>> getCurrencies() async {
    try {
      final response = await _supabase
          .from('currency_types')
          .select('*')
          .order('currency_name');
      
      return (response as List)
          .map((json) => Currency.fromJson(json))
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Get company details by ID
  Future<Map<String, dynamic>?> getCompanyDetails(String companyId) async {
    try {
      final response = await _supabase
          .from('companies')
          .select('*')
          .eq('company_id', companyId)
          .single();
      
      return response;
    } catch (e) {
      return null;
    }
  }

  /// Create a new company and return the company details if successful
  Future<Map<String, dynamic>?> createCompany({
    required String companyName,
    required String companyTypeId,
    required String baseCurrencyId,
  }) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('No user logged in');
      }

      // Create the company - company_code will be auto-generated by database trigger
      final companyResponse = await _supabase
          .from('companies')
          .insert({
            'company_name': companyName,
            'company_type_id': companyTypeId,
            'owner_id': userId,
            'base_currency_id': baseCurrencyId,
          })
          .select()
          .single();

      final companyId = companyResponse['company_id'];
      
      try {
        // Add user to company
        await _supabase
            .from('user_companies')
            .insert({
              'user_id': userId,
              'company_id': companyId,
            });

        // Check if owner role already exists for this company
        final existingRoles = await _supabase
            .from('roles')
            .select('role_id')
            .eq('company_id', companyId)
            .eq('role_name', 'Owner');

        String roleId;
        
        if (existingRoles.isEmpty) {
          // Create owner role only if it doesn't exist
          final roleResponse = await _supabase
              .from('roles')
              .insert({
                'role_name': 'Owner',
                'role_type': 'owner',
                'company_id': companyId,
                'description': 'Company owner with full permissions',
                'is_deletable': false,
              })
              .select()
              .single();
          
          roleId = roleResponse['role_id'];
          
          // Get all features to assign permissions
          final featuresResponse = await _supabase
              .from('features')
              .select('feature_id');

          // Give owner all permissions
          final permissions = (featuresResponse as List).map((feature) => {
            'role_id': roleId,
            'feature_id': feature['feature_id'],
            'can_access': true,
          }).toList();

          if (permissions.isNotEmpty) {
            await _supabase
                .from('role_permissions')
                .insert(permissions);
          }
        } else {
          // Use existing owner role
          roleId = existingRoles[0]['role_id'];
        }

        // Check if user already has this role
        final existingUserRole = await _supabase
            .from('user_roles')
            .select('user_role_id')
            .eq('user_id', userId)
            .eq('role_id', roleId);

        if (existingUserRole.isEmpty) {
          // Assign owner role to user only if they don't have it
          await _supabase
              .from('user_roles')
              .insert({
                'user_id': userId,
                'role_id': roleId,
              });
        }

        // Add company currency if base currency is specified
        await _supabase
            .from('company_currency')
            .insert({
              'company_id': companyId,
              'currency_id': baseCurrencyId,
            });

        // Get the complete company details to return
        final companyDetails = await getCompanyDetails(companyId);
        return companyDetails;
      } catch (innerError) {
        // If something goes wrong, we should ideally delete the company
        // But for now, just log the error
        
        // Try to clean up
        try {
          await _supabase
              .from('companies')
              .delete()
              .eq('company_id', companyId);
        } catch (deleteError) {
        }
        
        return null;
      }
    } catch (e) {
      return null;
    }
  }

  /// Join an existing company using company code (using efficient RPC)
  Future<Map<String, dynamic>?> joinCompany({
    required String companyCode,
  }) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('No user logged in');
      }

      // Use efficient RPC function for joining business
      final response = await _supabase.rpc(
        'join_business_by_code',
        params: {
          'p_user_id': userId,
          'p_business_code': companyCode.trim(),
        },
      );

      // Parse the JSON response
      final result = response as Map<String, dynamic>;
      
      // Check if the operation was successful
      if (result['success'] == true) {
        return {
          'company_id': result['company_id'],
          'company_name': result['company_name'] ?? result['business_name'],
          'business_type': result['business_type'],
          'role_assigned': result['role_assigned'],
          'joined_at': result['joined_at'],
        };
      } else {
        // Handle specific error cases
        final errorCode = result['error_code'];
        final errorMessage = result['error'] ?? 'Unknown error occurred';
        
        switch (errorCode) {
          case 'NOT_FOUND':
            throw Exception('Invalid company code');
          case 'ALREADY_MEMBER':
            throw Exception('You are already a member of this company');
          case 'OWNER_CANNOT_JOIN':
            throw Exception('You cannot join your own business as an employee');
          case 'INVALID_FORMAT':
          case 'INVALID_INPUT':
            throw Exception(errorMessage);
          default:
            throw Exception(errorMessage);
        }
      }
    } catch (e) {
      throw e;
    }
  }

  /// Validate business code format without database lookup
  Future<BusinessCodeValidation> validateBusinessCodeFormat(String businessCode) async {
    try {
      final response = await _supabase.rpc(
        'validate_business_code_format',
        params: {'p_business_code': businessCode},
      );

      final result = response as Map<String, dynamic>;
      
      return BusinessCodeValidation(
        isValid: result['valid'] ?? false,
        normalizedCode: result['normalized_code'],
        errorMessage: result['error'],
        errorCode: result['error_code'],
      );
    } catch (e) {
      return BusinessCodeValidation(
        isValid: false,
        errorMessage: 'Validation error: $e',
        errorCode: 'VALIDATION_ERROR',
      );
    }
  }

  /// Find a business (company or store) by business code
  Future<BusinessInfo?> findBusinessByCode(String businessCode) async {
    try {
      final response = await _supabase.rpc(
        'find_business_by_code',
        params: {'p_business_code': businessCode.trim()},
      );

      final result = response as Map<String, dynamic>;
      
      if (result['success'] == true) {
        return BusinessInfo.fromJson(result);
      } else {
        // Return null if business not found, let caller handle the error
        return null;
      }
    } catch (e) {
      return null;
    }
  }

  /// Get user's business memberships (companies and stores)
  Future<UserBusinessMemberships?> getUserBusinessMemberships(String userId) async {
    try {
      final response = await _supabase.rpc(
        'get_user_business_memberships',
        params: {'p_user_id': userId},
      );

      final result = response as Map<String, dynamic>;
      
      if (result['success'] == true) {
        return UserBusinessMemberships.fromJson(result);
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }

}

// Models
class CompanyType {
  final String companyTypeId;
  final String typeName;

  CompanyType({
    required this.companyTypeId,
    required this.typeName,
  });

  factory CompanyType.fromJson(Map<String, dynamic> json) {
    return CompanyType(
      companyTypeId: json['company_type_id'] as String,
      typeName: json['type_name'] as String,
    );
  }
}

class Currency {
  final String currencyId;
  final String currencyCode;
  final String currencyName;
  final String symbol;

  Currency({
    required this.currencyId,
    required this.currencyCode,
    required this.currencyName,
    required this.symbol,
  });

  factory Currency.fromJson(Map<String, dynamic> json) {
    return Currency(
      currencyId: json['currency_id'] as String,
      currencyCode: json['currency_code'] as String,
      currencyName: json['currency_name'] as String,
      symbol: json['symbol'] as String,
    );
  }
}

// New models for RPC functions

class BusinessCodeValidation {
  final bool isValid;
  final String? normalizedCode;
  final String? errorMessage;
  final String? errorCode;

  BusinessCodeValidation({
    required this.isValid,
    this.normalizedCode,
    this.errorMessage,
    this.errorCode,
  });
}

class BusinessInfo {
  final String businessType; // 'company' or 'store'
  final String businessId;
  final String businessName;
  final String businessCode;
  final String? companyId; // For stores, this is the parent company
  final String? companyName;
  final String? companyTypeId;
  final String? companyTypeName;
  final String ownerId;
  final DateTime createdAt;

  BusinessInfo({
    required this.businessType,
    required this.businessId,
    required this.businessName,
    required this.businessCode,
    this.companyId,
    this.companyName,
    this.companyTypeId,
    this.companyTypeName,
    required this.ownerId,
    required this.createdAt,
  });

  factory BusinessInfo.fromJson(Map<String, dynamic> json) {
    return BusinessInfo(
      businessType: json['business_type'] as String,
      businessId: json['business_id'] as String,
      businessName: json['business_name'] as String,
      businessCode: json['business_code'] as String,
      companyId: json['company_id'] as String?,
      companyName: json['company_name'] as String?,
      companyTypeId: json['company_type_id'] as String?,
      companyTypeName: json['company_type_name'] as String?,
      ownerId: json['owner_id'] as String,
      createdAt: DateTime.parse(json['created_at'] as String),
    );
  }
}

class UserRole {
  final String roleId;
  final String roleName;
  final String roleType;

  UserRole({
    required this.roleId,
    required this.roleName,
    required this.roleType,
  });

  factory UserRole.fromJson(Map<String, dynamic> json) {
    return UserRole(
      roleId: json['role_id'] as String,
      roleName: json['role_name'] as String,
      roleType: json['role_type'] as String,
    );
  }
}

class UserStore {
  final String storeId;
  final String storeName;
  final String storeCode;
  final String? storeAddress;

  UserStore({
    required this.storeId,
    required this.storeName,
    required this.storeCode,
    this.storeAddress,
  });

  factory UserStore.fromJson(Map<String, dynamic> json) {
    return UserStore(
      storeId: json['store_id'] as String,
      storeName: json['store_name'] as String,
      storeCode: json['store_code'] as String,
      storeAddress: json['store_address'] as String?,
    );
  }
}

class UserCompanyMembership {
  final String companyId;
  final String companyName;
  final String companyCode;
  final String? companyType;
  final bool isOwner;
  final DateTime joinedAt;
  final List<UserRole> roles;
  final List<UserStore> stores;

  UserCompanyMembership({
    required this.companyId,
    required this.companyName,
    required this.companyCode,
    this.companyType,
    required this.isOwner,
    required this.joinedAt,
    required this.roles,
    required this.stores,
  });

  factory UserCompanyMembership.fromJson(Map<String, dynamic> json) {
    return UserCompanyMembership(
      companyId: json['company_id'] as String,
      companyName: json['company_name'] as String,
      companyCode: json['company_code'] as String,
      companyType: json['company_type'] as String?,
      isOwner: json['is_owner'] as bool,
      joinedAt: DateTime.parse(json['joined_at'] as String),
      roles: (json['roles'] as List<dynamic>?)
              ?.map((role) => UserRole.fromJson(role as Map<String, dynamic>))
              .toList() ??
          [],
      stores: (json['stores'] as List<dynamic>?)
              ?.map((store) => UserStore.fromJson(store as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }
}

class UserBusinessMemberships {
  final String userId;
  final List<UserCompanyMembership> companies;
  final int totalCompanies;

  UserBusinessMemberships({
    required this.userId,
    required this.companies,
    required this.totalCompanies,
  });

  factory UserBusinessMemberships.fromJson(Map<String, dynamic> json) {
    return UserBusinessMemberships(
      userId: json['user_id'] as String,
      companies: (json['companies'] as List<dynamic>?)
              ?.map((company) => UserCompanyMembership.fromJson(company as Map<String, dynamic>))
              .toList() ??
          [],
      totalCompanies: json['total_companies'] as int? ?? 0,
    );
  }
}