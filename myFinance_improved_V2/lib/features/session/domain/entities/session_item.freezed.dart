// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'session_item.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SessionItem {
  String get itemId => throw _privateConstructorUsedError;
  String get sessionId => throw _privateConstructorUsedError;
  String get productId => throw _privateConstructorUsedError;
  String get productName => throw _privateConstructorUsedError;
  String? get sku => throw _privateConstructorUsedError;
  String? get barcode => throw _privateConstructorUsedError;
  String? get imageUrl => throw _privateConstructorUsedError;
  int get quantity => throw _privateConstructorUsedError;
  double? get unitPrice => throw _privateConstructorUsedError;
  DateTime get addedAt => throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SessionItemCopyWith<SessionItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SessionItemCopyWith<$Res> {
  factory $SessionItemCopyWith(
          SessionItem value, $Res Function(SessionItem) then) =
      _$SessionItemCopyWithImpl<$Res, SessionItem>;
  @useResult
  $Res call(
      {String itemId,
      String sessionId,
      String productId,
      String productName,
      String? sku,
      String? barcode,
      String? imageUrl,
      int quantity,
      double? unitPrice,
      DateTime addedAt,
      String? notes});
}

/// @nodoc
class _$SessionItemCopyWithImpl<$Res, $Val extends SessionItem>
    implements $SessionItemCopyWith<$Res> {
  _$SessionItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? itemId = null,
    Object? sessionId = null,
    Object? productId = null,
    Object? productName = null,
    Object? sku = freezed,
    Object? barcode = freezed,
    Object? imageUrl = freezed,
    Object? quantity = null,
    Object? unitPrice = freezed,
    Object? addedAt = null,
    Object? notes = freezed,
  }) {
    return _then(_value.copyWith(
      itemId: null == itemId
          ? _value.itemId
          : itemId // ignore: cast_nullable_to_non_nullable
              as String,
      sessionId: null == sessionId
          ? _value.sessionId
          : sessionId // ignore: cast_nullable_to_non_nullable
              as String,
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      productName: null == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String,
      sku: freezed == sku
          ? _value.sku
          : sku // ignore: cast_nullable_to_non_nullable
              as String?,
      barcode: freezed == barcode
          ? _value.barcode
          : barcode // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as double?,
      addedAt: null == addedAt
          ? _value.addedAt
          : addedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SessionItemImplCopyWith<$Res>
    implements $SessionItemCopyWith<$Res> {
  factory _$$SessionItemImplCopyWith(
          _$SessionItemImpl value, $Res Function(_$SessionItemImpl) then) =
      __$$SessionItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String itemId,
      String sessionId,
      String productId,
      String productName,
      String? sku,
      String? barcode,
      String? imageUrl,
      int quantity,
      double? unitPrice,
      DateTime addedAt,
      String? notes});
}

/// @nodoc
class __$$SessionItemImplCopyWithImpl<$Res>
    extends _$SessionItemCopyWithImpl<$Res, _$SessionItemImpl>
    implements _$$SessionItemImplCopyWith<$Res> {
  __$$SessionItemImplCopyWithImpl(
      _$SessionItemImpl _value, $Res Function(_$SessionItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? itemId = null,
    Object? sessionId = null,
    Object? productId = null,
    Object? productName = null,
    Object? sku = freezed,
    Object? barcode = freezed,
    Object? imageUrl = freezed,
    Object? quantity = null,
    Object? unitPrice = freezed,
    Object? addedAt = null,
    Object? notes = freezed,
  }) {
    return _then(_$SessionItemImpl(
      itemId: null == itemId
          ? _value.itemId
          : itemId // ignore: cast_nullable_to_non_nullable
              as String,
      sessionId: null == sessionId
          ? _value.sessionId
          : sessionId // ignore: cast_nullable_to_non_nullable
              as String,
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      productName: null == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String,
      sku: freezed == sku
          ? _value.sku
          : sku // ignore: cast_nullable_to_non_nullable
              as String?,
      barcode: freezed == barcode
          ? _value.barcode
          : barcode // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as double?,
      addedAt: null == addedAt
          ? _value.addedAt
          : addedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      notes: freezed == notes
          ? _value.notes
          : notes // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SessionItemImpl extends _SessionItem {
  const _$SessionItemImpl(
      {required this.itemId,
      required this.sessionId,
      required this.productId,
      required this.productName,
      this.sku,
      this.barcode,
      this.imageUrl,
      required this.quantity,
      this.unitPrice,
      required this.addedAt,
      this.notes})
      : super._();

  @override
  final String itemId;
  @override
  final String sessionId;
  @override
  final String productId;
  @override
  final String productName;
  @override
  final String? sku;
  @override
  final String? barcode;
  @override
  final String? imageUrl;
  @override
  final int quantity;
  @override
  final double? unitPrice;
  @override
  final DateTime addedAt;
  @override
  final String? notes;

  @override
  String toString() {
    return 'SessionItem(itemId: $itemId, sessionId: $sessionId, productId: $productId, productName: $productName, sku: $sku, barcode: $barcode, imageUrl: $imageUrl, quantity: $quantity, unitPrice: $unitPrice, addedAt: $addedAt, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SessionItemImpl &&
            (identical(other.itemId, itemId) || other.itemId == itemId) &&
            (identical(other.sessionId, sessionId) ||
                other.sessionId == sessionId) &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.productName, productName) ||
                other.productName == productName) &&
            (identical(other.sku, sku) || other.sku == sku) &&
            (identical(other.barcode, barcode) || other.barcode == barcode) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.addedAt, addedAt) || other.addedAt == addedAt) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @override
  int get hashCode => Object.hash(runtimeType, itemId, sessionId, productId,
      productName, sku, barcode, imageUrl, quantity, unitPrice, addedAt, notes);

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SessionItemImplCopyWith<_$SessionItemImpl> get copyWith =>
      __$$SessionItemImplCopyWithImpl<_$SessionItemImpl>(this, _$identity);
}

abstract class _SessionItem extends SessionItem {
  const factory _SessionItem(
      {required final String itemId,
      required final String sessionId,
      required final String productId,
      required final String productName,
      final String? sku,
      final String? barcode,
      final String? imageUrl,
      required final int quantity,
      final double? unitPrice,
      required final DateTime addedAt,
      final String? notes}) = _$SessionItemImpl;
  const _SessionItem._() : super._();

  @override
  String get itemId;
  @override
  String get sessionId;
  @override
  String get productId;
  @override
  String get productName;
  @override
  String? get sku;
  @override
  String? get barcode;
  @override
  String? get imageUrl;
  @override
  int get quantity;
  @override
  double? get unitPrice;
  @override
  DateTime get addedAt;
  @override
  String? get notes;

  /// Create a copy of SessionItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SessionItemImplCopyWith<_$SessionItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SessionItemInput {
  String get productId => throw _privateConstructorUsedError;
  int get quantity => throw _privateConstructorUsedError;
  int get quantityRejected => throw _privateConstructorUsedError;
  String? get variantId => throw _privateConstructorUsedError;

  /// Create a copy of SessionItemInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SessionItemInputCopyWith<SessionItemInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SessionItemInputCopyWith<$Res> {
  factory $SessionItemInputCopyWith(
          SessionItemInput value, $Res Function(SessionItemInput) then) =
      _$SessionItemInputCopyWithImpl<$Res, SessionItemInput>;
  @useResult
  $Res call(
      {String productId,
      int quantity,
      int quantityRejected,
      String? variantId});
}

/// @nodoc
class _$SessionItemInputCopyWithImpl<$Res, $Val extends SessionItemInput>
    implements $SessionItemInputCopyWith<$Res> {
  _$SessionItemInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SessionItemInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
    Object? quantity = null,
    Object? quantityRejected = null,
    Object? variantId = freezed,
  }) {
    return _then(_value.copyWith(
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      quantityRejected: null == quantityRejected
          ? _value.quantityRejected
          : quantityRejected // ignore: cast_nullable_to_non_nullable
              as int,
      variantId: freezed == variantId
          ? _value.variantId
          : variantId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SessionItemInputImplCopyWith<$Res>
    implements $SessionItemInputCopyWith<$Res> {
  factory _$$SessionItemInputImplCopyWith(_$SessionItemInputImpl value,
          $Res Function(_$SessionItemInputImpl) then) =
      __$$SessionItemInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String productId,
      int quantity,
      int quantityRejected,
      String? variantId});
}

/// @nodoc
class __$$SessionItemInputImplCopyWithImpl<$Res>
    extends _$SessionItemInputCopyWithImpl<$Res, _$SessionItemInputImpl>
    implements _$$SessionItemInputImplCopyWith<$Res> {
  __$$SessionItemInputImplCopyWithImpl(_$SessionItemInputImpl _value,
      $Res Function(_$SessionItemInputImpl) _then)
      : super(_value, _then);

  /// Create a copy of SessionItemInput
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
    Object? quantity = null,
    Object? quantityRejected = null,
    Object? variantId = freezed,
  }) {
    return _then(_$SessionItemInputImpl(
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      quantity: null == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as int,
      quantityRejected: null == quantityRejected
          ? _value.quantityRejected
          : quantityRejected // ignore: cast_nullable_to_non_nullable
              as int,
      variantId: freezed == variantId
          ? _value.variantId
          : variantId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SessionItemInputImpl implements _SessionItemInput {
  const _$SessionItemInputImpl(
      {required this.productId,
      required this.quantity,
      this.quantityRejected = 0,
      this.variantId});

  @override
  final String productId;
  @override
  final int quantity;
  @override
  @JsonKey()
  final int quantityRejected;
  @override
  final String? variantId;

  @override
  String toString() {
    return 'SessionItemInput(productId: $productId, quantity: $quantity, quantityRejected: $quantityRejected, variantId: $variantId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SessionItemInputImpl &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.quantityRejected, quantityRejected) ||
                other.quantityRejected == quantityRejected) &&
            (identical(other.variantId, variantId) ||
                other.variantId == variantId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, productId, quantity, quantityRejected, variantId);

  /// Create a copy of SessionItemInput
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SessionItemInputImplCopyWith<_$SessionItemInputImpl> get copyWith =>
      __$$SessionItemInputImplCopyWithImpl<_$SessionItemInputImpl>(
          this, _$identity);
}

abstract class _SessionItemInput implements SessionItemInput {
  const factory _SessionItemInput(
      {required final String productId,
      required final int quantity,
      final int quantityRejected,
      final String? variantId}) = _$SessionItemInputImpl;

  @override
  String get productId;
  @override
  int get quantity;
  @override
  int get quantityRejected;
  @override
  String? get variantId;

  /// Create a copy of SessionItemInput
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SessionItemInputImplCopyWith<_$SessionItemInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddSessionItemsResponse {
  bool get success => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  int get itemsAdded => throw _privateConstructorUsedError;

  /// Create a copy of AddSessionItemsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AddSessionItemsResponseCopyWith<AddSessionItemsResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddSessionItemsResponseCopyWith<$Res> {
  factory $AddSessionItemsResponseCopyWith(AddSessionItemsResponse value,
          $Res Function(AddSessionItemsResponse) then) =
      _$AddSessionItemsResponseCopyWithImpl<$Res, AddSessionItemsResponse>;
  @useResult
  $Res call({bool success, String? message, int itemsAdded});
}

/// @nodoc
class _$AddSessionItemsResponseCopyWithImpl<$Res,
        $Val extends AddSessionItemsResponse>
    implements $AddSessionItemsResponseCopyWith<$Res> {
  _$AddSessionItemsResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddSessionItemsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? message = freezed,
    Object? itemsAdded = null,
  }) {
    return _then(_value.copyWith(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      itemsAdded: null == itemsAdded
          ? _value.itemsAdded
          : itemsAdded // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AddSessionItemsResponseImplCopyWith<$Res>
    implements $AddSessionItemsResponseCopyWith<$Res> {
  factory _$$AddSessionItemsResponseImplCopyWith(
          _$AddSessionItemsResponseImpl value,
          $Res Function(_$AddSessionItemsResponseImpl) then) =
      __$$AddSessionItemsResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool success, String? message, int itemsAdded});
}

/// @nodoc
class __$$AddSessionItemsResponseImplCopyWithImpl<$Res>
    extends _$AddSessionItemsResponseCopyWithImpl<$Res,
        _$AddSessionItemsResponseImpl>
    implements _$$AddSessionItemsResponseImplCopyWith<$Res> {
  __$$AddSessionItemsResponseImplCopyWithImpl(
      _$AddSessionItemsResponseImpl _value,
      $Res Function(_$AddSessionItemsResponseImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddSessionItemsResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
    Object? message = freezed,
    Object? itemsAdded = null,
  }) {
    return _then(_$AddSessionItemsResponseImpl(
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      itemsAdded: null == itemsAdded
          ? _value.itemsAdded
          : itemsAdded // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddSessionItemsResponseImpl implements _AddSessionItemsResponse {
  const _$AddSessionItemsResponseImpl(
      {required this.success, this.message, this.itemsAdded = 0});

  @override
  final bool success;
  @override
  final String? message;
  @override
  @JsonKey()
  final int itemsAdded;

  @override
  String toString() {
    return 'AddSessionItemsResponse(success: $success, message: $message, itemsAdded: $itemsAdded)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddSessionItemsResponseImpl &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.itemsAdded, itemsAdded) ||
                other.itemsAdded == itemsAdded));
  }

  @override
  int get hashCode => Object.hash(runtimeType, success, message, itemsAdded);

  /// Create a copy of AddSessionItemsResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddSessionItemsResponseImplCopyWith<_$AddSessionItemsResponseImpl>
      get copyWith => __$$AddSessionItemsResponseImplCopyWithImpl<
          _$AddSessionItemsResponseImpl>(this, _$identity);
}

abstract class _AddSessionItemsResponse implements AddSessionItemsResponse {
  const factory _AddSessionItemsResponse(
      {required final bool success,
      final String? message,
      final int itemsAdded}) = _$AddSessionItemsResponseImpl;

  @override
  bool get success;
  @override
  String? get message;
  @override
  int get itemsAdded;

  /// Create a copy of AddSessionItemsResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddSessionItemsResponseImplCopyWith<_$AddSessionItemsResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProductSearchResult {
  String get productId => throw _privateConstructorUsedError;
  String get productName => throw _privateConstructorUsedError;
  String? get sku => throw _privateConstructorUsedError;
  String? get barcode => throw _privateConstructorUsedError;
  String? get imageUrl => throw _privateConstructorUsedError;
  String? get brandName => throw _privateConstructorUsedError;
  String? get categoryName => throw _privateConstructorUsedError;
  double get sellingPrice => throw _privateConstructorUsedError;
  int get currentStock =>
      throw _privateConstructorUsedError; // v6 variant fields
  String? get variantId => throw _privateConstructorUsedError;
  String? get variantName => throw _privateConstructorUsedError;
  String? get variantSku => throw _privateConstructorUsedError;
  String? get variantBarcode => throw _privateConstructorUsedError;
  String? get displayName => throw _privateConstructorUsedError;
  String? get displaySku => throw _privateConstructorUsedError;
  String? get displayBarcode => throw _privateConstructorUsedError;
  bool get hasVariants => throw _privateConstructorUsedError;

  /// Create a copy of ProductSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProductSearchResultCopyWith<ProductSearchResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProductSearchResultCopyWith<$Res> {
  factory $ProductSearchResultCopyWith(
          ProductSearchResult value, $Res Function(ProductSearchResult) then) =
      _$ProductSearchResultCopyWithImpl<$Res, ProductSearchResult>;
  @useResult
  $Res call(
      {String productId,
      String productName,
      String? sku,
      String? barcode,
      String? imageUrl,
      String? brandName,
      String? categoryName,
      double sellingPrice,
      int currentStock,
      String? variantId,
      String? variantName,
      String? variantSku,
      String? variantBarcode,
      String? displayName,
      String? displaySku,
      String? displayBarcode,
      bool hasVariants});
}

/// @nodoc
class _$ProductSearchResultCopyWithImpl<$Res, $Val extends ProductSearchResult>
    implements $ProductSearchResultCopyWith<$Res> {
  _$ProductSearchResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProductSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
    Object? productName = null,
    Object? sku = freezed,
    Object? barcode = freezed,
    Object? imageUrl = freezed,
    Object? brandName = freezed,
    Object? categoryName = freezed,
    Object? sellingPrice = null,
    Object? currentStock = null,
    Object? variantId = freezed,
    Object? variantName = freezed,
    Object? variantSku = freezed,
    Object? variantBarcode = freezed,
    Object? displayName = freezed,
    Object? displaySku = freezed,
    Object? displayBarcode = freezed,
    Object? hasVariants = null,
  }) {
    return _then(_value.copyWith(
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      productName: null == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String,
      sku: freezed == sku
          ? _value.sku
          : sku // ignore: cast_nullable_to_non_nullable
              as String?,
      barcode: freezed == barcode
          ? _value.barcode
          : barcode // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      brandName: freezed == brandName
          ? _value.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String?,
      categoryName: freezed == categoryName
          ? _value.categoryName
          : categoryName // ignore: cast_nullable_to_non_nullable
              as String?,
      sellingPrice: null == sellingPrice
          ? _value.sellingPrice
          : sellingPrice // ignore: cast_nullable_to_non_nullable
              as double,
      currentStock: null == currentStock
          ? _value.currentStock
          : currentStock // ignore: cast_nullable_to_non_nullable
              as int,
      variantId: freezed == variantId
          ? _value.variantId
          : variantId // ignore: cast_nullable_to_non_nullable
              as String?,
      variantName: freezed == variantName
          ? _value.variantName
          : variantName // ignore: cast_nullable_to_non_nullable
              as String?,
      variantSku: freezed == variantSku
          ? _value.variantSku
          : variantSku // ignore: cast_nullable_to_non_nullable
              as String?,
      variantBarcode: freezed == variantBarcode
          ? _value.variantBarcode
          : variantBarcode // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      displaySku: freezed == displaySku
          ? _value.displaySku
          : displaySku // ignore: cast_nullable_to_non_nullable
              as String?,
      displayBarcode: freezed == displayBarcode
          ? _value.displayBarcode
          : displayBarcode // ignore: cast_nullable_to_non_nullable
              as String?,
      hasVariants: null == hasVariants
          ? _value.hasVariants
          : hasVariants // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProductSearchResultImplCopyWith<$Res>
    implements $ProductSearchResultCopyWith<$Res> {
  factory _$$ProductSearchResultImplCopyWith(_$ProductSearchResultImpl value,
          $Res Function(_$ProductSearchResultImpl) then) =
      __$$ProductSearchResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String productId,
      String productName,
      String? sku,
      String? barcode,
      String? imageUrl,
      String? brandName,
      String? categoryName,
      double sellingPrice,
      int currentStock,
      String? variantId,
      String? variantName,
      String? variantSku,
      String? variantBarcode,
      String? displayName,
      String? displaySku,
      String? displayBarcode,
      bool hasVariants});
}

/// @nodoc
class __$$ProductSearchResultImplCopyWithImpl<$Res>
    extends _$ProductSearchResultCopyWithImpl<$Res, _$ProductSearchResultImpl>
    implements _$$ProductSearchResultImplCopyWith<$Res> {
  __$$ProductSearchResultImplCopyWithImpl(_$ProductSearchResultImpl _value,
      $Res Function(_$ProductSearchResultImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProductSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
    Object? productName = null,
    Object? sku = freezed,
    Object? barcode = freezed,
    Object? imageUrl = freezed,
    Object? brandName = freezed,
    Object? categoryName = freezed,
    Object? sellingPrice = null,
    Object? currentStock = null,
    Object? variantId = freezed,
    Object? variantName = freezed,
    Object? variantSku = freezed,
    Object? variantBarcode = freezed,
    Object? displayName = freezed,
    Object? displaySku = freezed,
    Object? displayBarcode = freezed,
    Object? hasVariants = null,
  }) {
    return _then(_$ProductSearchResultImpl(
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      productName: null == productName
          ? _value.productName
          : productName // ignore: cast_nullable_to_non_nullable
              as String,
      sku: freezed == sku
          ? _value.sku
          : sku // ignore: cast_nullable_to_non_nullable
              as String?,
      barcode: freezed == barcode
          ? _value.barcode
          : barcode // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      brandName: freezed == brandName
          ? _value.brandName
          : brandName // ignore: cast_nullable_to_non_nullable
              as String?,
      categoryName: freezed == categoryName
          ? _value.categoryName
          : categoryName // ignore: cast_nullable_to_non_nullable
              as String?,
      sellingPrice: null == sellingPrice
          ? _value.sellingPrice
          : sellingPrice // ignore: cast_nullable_to_non_nullable
              as double,
      currentStock: null == currentStock
          ? _value.currentStock
          : currentStock // ignore: cast_nullable_to_non_nullable
              as int,
      variantId: freezed == variantId
          ? _value.variantId
          : variantId // ignore: cast_nullable_to_non_nullable
              as String?,
      variantName: freezed == variantName
          ? _value.variantName
          : variantName // ignore: cast_nullable_to_non_nullable
              as String?,
      variantSku: freezed == variantSku
          ? _value.variantSku
          : variantSku // ignore: cast_nullable_to_non_nullable
              as String?,
      variantBarcode: freezed == variantBarcode
          ? _value.variantBarcode
          : variantBarcode // ignore: cast_nullable_to_non_nullable
              as String?,
      displayName: freezed == displayName
          ? _value.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      displaySku: freezed == displaySku
          ? _value.displaySku
          : displaySku // ignore: cast_nullable_to_non_nullable
              as String?,
      displayBarcode: freezed == displayBarcode
          ? _value.displayBarcode
          : displayBarcode // ignore: cast_nullable_to_non_nullable
              as String?,
      hasVariants: null == hasVariants
          ? _value.hasVariants
          : hasVariants // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ProductSearchResultImpl extends _ProductSearchResult {
  const _$ProductSearchResultImpl(
      {required this.productId,
      required this.productName,
      this.sku,
      this.barcode,
      this.imageUrl,
      this.brandName,
      this.categoryName,
      this.sellingPrice = 0,
      this.currentStock = 0,
      this.variantId,
      this.variantName,
      this.variantSku,
      this.variantBarcode,
      this.displayName,
      this.displaySku,
      this.displayBarcode,
      this.hasVariants = false})
      : super._();

  @override
  final String productId;
  @override
  final String productName;
  @override
  final String? sku;
  @override
  final String? barcode;
  @override
  final String? imageUrl;
  @override
  final String? brandName;
  @override
  final String? categoryName;
  @override
  @JsonKey()
  final double sellingPrice;
  @override
  @JsonKey()
  final int currentStock;
// v6 variant fields
  @override
  final String? variantId;
  @override
  final String? variantName;
  @override
  final String? variantSku;
  @override
  final String? variantBarcode;
  @override
  final String? displayName;
  @override
  final String? displaySku;
  @override
  final String? displayBarcode;
  @override
  @JsonKey()
  final bool hasVariants;

  @override
  String toString() {
    return 'ProductSearchResult(productId: $productId, productName: $productName, sku: $sku, barcode: $barcode, imageUrl: $imageUrl, brandName: $brandName, categoryName: $categoryName, sellingPrice: $sellingPrice, currentStock: $currentStock, variantId: $variantId, variantName: $variantName, variantSku: $variantSku, variantBarcode: $variantBarcode, displayName: $displayName, displaySku: $displaySku, displayBarcode: $displayBarcode, hasVariants: $hasVariants)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductSearchResultImpl &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.productName, productName) ||
                other.productName == productName) &&
            (identical(other.sku, sku) || other.sku == sku) &&
            (identical(other.barcode, barcode) || other.barcode == barcode) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl) &&
            (identical(other.brandName, brandName) ||
                other.brandName == brandName) &&
            (identical(other.categoryName, categoryName) ||
                other.categoryName == categoryName) &&
            (identical(other.sellingPrice, sellingPrice) ||
                other.sellingPrice == sellingPrice) &&
            (identical(other.currentStock, currentStock) ||
                other.currentStock == currentStock) &&
            (identical(other.variantId, variantId) ||
                other.variantId == variantId) &&
            (identical(other.variantName, variantName) ||
                other.variantName == variantName) &&
            (identical(other.variantSku, variantSku) ||
                other.variantSku == variantSku) &&
            (identical(other.variantBarcode, variantBarcode) ||
                other.variantBarcode == variantBarcode) &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.displaySku, displaySku) ||
                other.displaySku == displaySku) &&
            (identical(other.displayBarcode, displayBarcode) ||
                other.displayBarcode == displayBarcode) &&
            (identical(other.hasVariants, hasVariants) ||
                other.hasVariants == hasVariants));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      productId,
      productName,
      sku,
      barcode,
      imageUrl,
      brandName,
      categoryName,
      sellingPrice,
      currentStock,
      variantId,
      variantName,
      variantSku,
      variantBarcode,
      displayName,
      displaySku,
      displayBarcode,
      hasVariants);

  /// Create a copy of ProductSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductSearchResultImplCopyWith<_$ProductSearchResultImpl> get copyWith =>
      __$$ProductSearchResultImplCopyWithImpl<_$ProductSearchResultImpl>(
          this, _$identity);
}

abstract class _ProductSearchResult extends ProductSearchResult {
  const factory _ProductSearchResult(
      {required final String productId,
      required final String productName,
      final String? sku,
      final String? barcode,
      final String? imageUrl,
      final String? brandName,
      final String? categoryName,
      final double sellingPrice,
      final int currentStock,
      final String? variantId,
      final String? variantName,
      final String? variantSku,
      final String? variantBarcode,
      final String? displayName,
      final String? displaySku,
      final String? displayBarcode,
      final bool hasVariants}) = _$ProductSearchResultImpl;
  const _ProductSearchResult._() : super._();

  @override
  String get productId;
  @override
  String get productName;
  @override
  String? get sku;
  @override
  String? get barcode;
  @override
  String? get imageUrl;
  @override
  String? get brandName;
  @override
  String? get categoryName;
  @override
  double get sellingPrice;
  @override
  int get currentStock; // v6 variant fields
  @override
  String? get variantId;
  @override
  String? get variantName;
  @override
  String? get variantSku;
  @override
  String? get variantBarcode;
  @override
  String? get displayName;
  @override
  String? get displaySku;
  @override
  String? get displayBarcode;
  @override
  bool get hasVariants;

  /// Create a copy of ProductSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProductSearchResultImplCopyWith<_$ProductSearchResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ProductSearchResponse {
  List<ProductSearchResult> get products => throw _privateConstructorUsedError;
  int get totalCount => throw _privateConstructorUsedError;
  int get page => throw _privateConstructorUsedError;
  int get limit => throw _privateConstructorUsedError;
  int get totalPages => throw _privateConstructorUsedError;
  bool get hasNext => throw _privateConstructorUsedError;

  /// Create a copy of ProductSearchResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProductSearchResponseCopyWith<ProductSearchResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProductSearchResponseCopyWith<$Res> {
  factory $ProductSearchResponseCopyWith(ProductSearchResponse value,
          $Res Function(ProductSearchResponse) then) =
      _$ProductSearchResponseCopyWithImpl<$Res, ProductSearchResponse>;
  @useResult
  $Res call(
      {List<ProductSearchResult> products,
      int totalCount,
      int page,
      int limit,
      int totalPages,
      bool hasNext});
}

/// @nodoc
class _$ProductSearchResponseCopyWithImpl<$Res,
        $Val extends ProductSearchResponse>
    implements $ProductSearchResponseCopyWith<$Res> {
  _$ProductSearchResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProductSearchResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? products = null,
    Object? totalCount = null,
    Object? page = null,
    Object? limit = null,
    Object? totalPages = null,
    Object? hasNext = null,
  }) {
    return _then(_value.copyWith(
      products: null == products
          ? _value.products
          : products // ignore: cast_nullable_to_non_nullable
              as List<ProductSearchResult>,
      totalCount: null == totalCount
          ? _value.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      totalPages: null == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int,
      hasNext: null == hasNext
          ? _value.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProductSearchResponseImplCopyWith<$Res>
    implements $ProductSearchResponseCopyWith<$Res> {
  factory _$$ProductSearchResponseImplCopyWith(
          _$ProductSearchResponseImpl value,
          $Res Function(_$ProductSearchResponseImpl) then) =
      __$$ProductSearchResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<ProductSearchResult> products,
      int totalCount,
      int page,
      int limit,
      int totalPages,
      bool hasNext});
}

/// @nodoc
class __$$ProductSearchResponseImplCopyWithImpl<$Res>
    extends _$ProductSearchResponseCopyWithImpl<$Res,
        _$ProductSearchResponseImpl>
    implements _$$ProductSearchResponseImplCopyWith<$Res> {
  __$$ProductSearchResponseImplCopyWithImpl(_$ProductSearchResponseImpl _value,
      $Res Function(_$ProductSearchResponseImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProductSearchResponse
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? products = null,
    Object? totalCount = null,
    Object? page = null,
    Object? limit = null,
    Object? totalPages = null,
    Object? hasNext = null,
  }) {
    return _then(_$ProductSearchResponseImpl(
      products: null == products
          ? _value._products
          : products // ignore: cast_nullable_to_non_nullable
              as List<ProductSearchResult>,
      totalCount: null == totalCount
          ? _value.totalCount
          : totalCount // ignore: cast_nullable_to_non_nullable
              as int,
      page: null == page
          ? _value.page
          : page // ignore: cast_nullable_to_non_nullable
              as int,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      totalPages: null == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int,
      hasNext: null == hasNext
          ? _value.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ProductSearchResponseImpl implements _ProductSearchResponse {
  const _$ProductSearchResponseImpl(
      {required final List<ProductSearchResult> products,
      this.totalCount = 0,
      this.page = 1,
      this.limit = 20,
      this.totalPages = 1,
      this.hasNext = false})
      : _products = products;

  final List<ProductSearchResult> _products;
  @override
  List<ProductSearchResult> get products {
    if (_products is EqualUnmodifiableListView) return _products;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_products);
  }

  @override
  @JsonKey()
  final int totalCount;
  @override
  @JsonKey()
  final int page;
  @override
  @JsonKey()
  final int limit;
  @override
  @JsonKey()
  final int totalPages;
  @override
  @JsonKey()
  final bool hasNext;

  @override
  String toString() {
    return 'ProductSearchResponse(products: $products, totalCount: $totalCount, page: $page, limit: $limit, totalPages: $totalPages, hasNext: $hasNext)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProductSearchResponseImpl &&
            const DeepCollectionEquality().equals(other._products, _products) &&
            (identical(other.totalCount, totalCount) ||
                other.totalCount == totalCount) &&
            (identical(other.page, page) || other.page == page) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_products),
      totalCount,
      page,
      limit,
      totalPages,
      hasNext);

  /// Create a copy of ProductSearchResponse
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProductSearchResponseImplCopyWith<_$ProductSearchResponseImpl>
      get copyWith => __$$ProductSearchResponseImplCopyWithImpl<
          _$ProductSearchResponseImpl>(this, _$identity);
}

abstract class _ProductSearchResponse implements ProductSearchResponse {
  const factory _ProductSearchResponse(
      {required final List<ProductSearchResult> products,
      final int totalCount,
      final int page,
      final int limit,
      final int totalPages,
      final bool hasNext}) = _$ProductSearchResponseImpl;

  @override
  List<ProductSearchResult> get products;
  @override
  int get totalCount;
  @override
  int get page;
  @override
  int get limit;
  @override
  int get totalPages;
  @override
  bool get hasNext;

  /// Create a copy of ProductSearchResponse
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProductSearchResponseImplCopyWith<_$ProductSearchResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}
