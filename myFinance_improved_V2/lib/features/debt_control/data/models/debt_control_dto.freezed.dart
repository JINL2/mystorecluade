// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'debt_control_dto.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

KpiMetricsDto _$KpiMetricsDtoFromJson(Map<String, dynamic> json) {
  return _KpiMetricsDto.fromJson(json);
}

/// @nodoc
mixin _$KpiMetricsDto {
  double get netPosition => throw _privateConstructorUsedError;
  double get netPositionTrend => throw _privateConstructorUsedError;
  int get avgDaysOutstanding => throw _privateConstructorUsedError;
  double get agingTrend => throw _privateConstructorUsedError;
  double get collectionRate => throw _privateConstructorUsedError;
  double get collectionTrend => throw _privateConstructorUsedError;
  int get criticalCount => throw _privateConstructorUsedError;
  double get criticalTrend => throw _privateConstructorUsedError;
  double get totalReceivable => throw _privateConstructorUsedError;
  double get totalPayable => throw _privateConstructorUsedError;
  int get transactionCount => throw _privateConstructorUsedError;

  /// Serializes this KpiMetricsDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of KpiMetricsDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $KpiMetricsDtoCopyWith<KpiMetricsDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KpiMetricsDtoCopyWith<$Res> {
  factory $KpiMetricsDtoCopyWith(
          KpiMetricsDto value, $Res Function(KpiMetricsDto) then) =
      _$KpiMetricsDtoCopyWithImpl<$Res, KpiMetricsDto>;
  @useResult
  $Res call(
      {double netPosition,
      double netPositionTrend,
      int avgDaysOutstanding,
      double agingTrend,
      double collectionRate,
      double collectionTrend,
      int criticalCount,
      double criticalTrend,
      double totalReceivable,
      double totalPayable,
      int transactionCount});
}

/// @nodoc
class _$KpiMetricsDtoCopyWithImpl<$Res, $Val extends KpiMetricsDto>
    implements $KpiMetricsDtoCopyWith<$Res> {
  _$KpiMetricsDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of KpiMetricsDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? netPosition = null,
    Object? netPositionTrend = null,
    Object? avgDaysOutstanding = null,
    Object? agingTrend = null,
    Object? collectionRate = null,
    Object? collectionTrend = null,
    Object? criticalCount = null,
    Object? criticalTrend = null,
    Object? totalReceivable = null,
    Object? totalPayable = null,
    Object? transactionCount = null,
  }) {
    return _then(_value.copyWith(
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      netPositionTrend: null == netPositionTrend
          ? _value.netPositionTrend
          : netPositionTrend // ignore: cast_nullable_to_non_nullable
              as double,
      avgDaysOutstanding: null == avgDaysOutstanding
          ? _value.avgDaysOutstanding
          : avgDaysOutstanding // ignore: cast_nullable_to_non_nullable
              as int,
      agingTrend: null == agingTrend
          ? _value.agingTrend
          : agingTrend // ignore: cast_nullable_to_non_nullable
              as double,
      collectionRate: null == collectionRate
          ? _value.collectionRate
          : collectionRate // ignore: cast_nullable_to_non_nullable
              as double,
      collectionTrend: null == collectionTrend
          ? _value.collectionTrend
          : collectionTrend // ignore: cast_nullable_to_non_nullable
              as double,
      criticalCount: null == criticalCount
          ? _value.criticalCount
          : criticalCount // ignore: cast_nullable_to_non_nullable
              as int,
      criticalTrend: null == criticalTrend
          ? _value.criticalTrend
          : criticalTrend // ignore: cast_nullable_to_non_nullable
              as double,
      totalReceivable: null == totalReceivable
          ? _value.totalReceivable
          : totalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      totalPayable: null == totalPayable
          ? _value.totalPayable
          : totalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KpiMetricsDtoImplCopyWith<$Res>
    implements $KpiMetricsDtoCopyWith<$Res> {
  factory _$$KpiMetricsDtoImplCopyWith(
          _$KpiMetricsDtoImpl value, $Res Function(_$KpiMetricsDtoImpl) then) =
      __$$KpiMetricsDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double netPosition,
      double netPositionTrend,
      int avgDaysOutstanding,
      double agingTrend,
      double collectionRate,
      double collectionTrend,
      int criticalCount,
      double criticalTrend,
      double totalReceivable,
      double totalPayable,
      int transactionCount});
}

/// @nodoc
class __$$KpiMetricsDtoImplCopyWithImpl<$Res>
    extends _$KpiMetricsDtoCopyWithImpl<$Res, _$KpiMetricsDtoImpl>
    implements _$$KpiMetricsDtoImplCopyWith<$Res> {
  __$$KpiMetricsDtoImplCopyWithImpl(
      _$KpiMetricsDtoImpl _value, $Res Function(_$KpiMetricsDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of KpiMetricsDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? netPosition = null,
    Object? netPositionTrend = null,
    Object? avgDaysOutstanding = null,
    Object? agingTrend = null,
    Object? collectionRate = null,
    Object? collectionTrend = null,
    Object? criticalCount = null,
    Object? criticalTrend = null,
    Object? totalReceivable = null,
    Object? totalPayable = null,
    Object? transactionCount = null,
  }) {
    return _then(_$KpiMetricsDtoImpl(
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      netPositionTrend: null == netPositionTrend
          ? _value.netPositionTrend
          : netPositionTrend // ignore: cast_nullable_to_non_nullable
              as double,
      avgDaysOutstanding: null == avgDaysOutstanding
          ? _value.avgDaysOutstanding
          : avgDaysOutstanding // ignore: cast_nullable_to_non_nullable
              as int,
      agingTrend: null == agingTrend
          ? _value.agingTrend
          : agingTrend // ignore: cast_nullable_to_non_nullable
              as double,
      collectionRate: null == collectionRate
          ? _value.collectionRate
          : collectionRate // ignore: cast_nullable_to_non_nullable
              as double,
      collectionTrend: null == collectionTrend
          ? _value.collectionTrend
          : collectionTrend // ignore: cast_nullable_to_non_nullable
              as double,
      criticalCount: null == criticalCount
          ? _value.criticalCount
          : criticalCount // ignore: cast_nullable_to_non_nullable
              as int,
      criticalTrend: null == criticalTrend
          ? _value.criticalTrend
          : criticalTrend // ignore: cast_nullable_to_non_nullable
              as double,
      totalReceivable: null == totalReceivable
          ? _value.totalReceivable
          : totalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      totalPayable: null == totalPayable
          ? _value.totalPayable
          : totalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KpiMetricsDtoImpl implements _KpiMetricsDto {
  const _$KpiMetricsDtoImpl(
      {this.netPosition = 0.0,
      this.netPositionTrend = 0.0,
      this.avgDaysOutstanding = 0,
      this.agingTrend = 0.0,
      this.collectionRate = 0.0,
      this.collectionTrend = 0.0,
      this.criticalCount = 0,
      this.criticalTrend = 0.0,
      this.totalReceivable = 0.0,
      this.totalPayable = 0.0,
      this.transactionCount = 0});

  factory _$KpiMetricsDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$KpiMetricsDtoImplFromJson(json);

  @override
  @JsonKey()
  final double netPosition;
  @override
  @JsonKey()
  final double netPositionTrend;
  @override
  @JsonKey()
  final int avgDaysOutstanding;
  @override
  @JsonKey()
  final double agingTrend;
  @override
  @JsonKey()
  final double collectionRate;
  @override
  @JsonKey()
  final double collectionTrend;
  @override
  @JsonKey()
  final int criticalCount;
  @override
  @JsonKey()
  final double criticalTrend;
  @override
  @JsonKey()
  final double totalReceivable;
  @override
  @JsonKey()
  final double totalPayable;
  @override
  @JsonKey()
  final int transactionCount;

  @override
  String toString() {
    return 'KpiMetricsDto(netPosition: $netPosition, netPositionTrend: $netPositionTrend, avgDaysOutstanding: $avgDaysOutstanding, agingTrend: $agingTrend, collectionRate: $collectionRate, collectionTrend: $collectionTrend, criticalCount: $criticalCount, criticalTrend: $criticalTrend, totalReceivable: $totalReceivable, totalPayable: $totalPayable, transactionCount: $transactionCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KpiMetricsDtoImpl &&
            (identical(other.netPosition, netPosition) ||
                other.netPosition == netPosition) &&
            (identical(other.netPositionTrend, netPositionTrend) ||
                other.netPositionTrend == netPositionTrend) &&
            (identical(other.avgDaysOutstanding, avgDaysOutstanding) ||
                other.avgDaysOutstanding == avgDaysOutstanding) &&
            (identical(other.agingTrend, agingTrend) ||
                other.agingTrend == agingTrend) &&
            (identical(other.collectionRate, collectionRate) ||
                other.collectionRate == collectionRate) &&
            (identical(other.collectionTrend, collectionTrend) ||
                other.collectionTrend == collectionTrend) &&
            (identical(other.criticalCount, criticalCount) ||
                other.criticalCount == criticalCount) &&
            (identical(other.criticalTrend, criticalTrend) ||
                other.criticalTrend == criticalTrend) &&
            (identical(other.totalReceivable, totalReceivable) ||
                other.totalReceivable == totalReceivable) &&
            (identical(other.totalPayable, totalPayable) ||
                other.totalPayable == totalPayable) &&
            (identical(other.transactionCount, transactionCount) ||
                other.transactionCount == transactionCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      netPosition,
      netPositionTrend,
      avgDaysOutstanding,
      agingTrend,
      collectionRate,
      collectionTrend,
      criticalCount,
      criticalTrend,
      totalReceivable,
      totalPayable,
      transactionCount);

  /// Create a copy of KpiMetricsDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$KpiMetricsDtoImplCopyWith<_$KpiMetricsDtoImpl> get copyWith =>
      __$$KpiMetricsDtoImplCopyWithImpl<_$KpiMetricsDtoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$KpiMetricsDtoImplToJson(
      this,
    );
  }
}

abstract class _KpiMetricsDto implements KpiMetricsDto {
  const factory _KpiMetricsDto(
      {final double netPosition,
      final double netPositionTrend,
      final int avgDaysOutstanding,
      final double agingTrend,
      final double collectionRate,
      final double collectionTrend,
      final int criticalCount,
      final double criticalTrend,
      final double totalReceivable,
      final double totalPayable,
      final int transactionCount}) = _$KpiMetricsDtoImpl;

  factory _KpiMetricsDto.fromJson(Map<String, dynamic> json) =
      _$KpiMetricsDtoImpl.fromJson;

  @override
  double get netPosition;
  @override
  double get netPositionTrend;
  @override
  int get avgDaysOutstanding;
  @override
  double get agingTrend;
  @override
  double get collectionRate;
  @override
  double get collectionTrend;
  @override
  int get criticalCount;
  @override
  double get criticalTrend;
  @override
  double get totalReceivable;
  @override
  double get totalPayable;
  @override
  int get transactionCount;

  /// Create a copy of KpiMetricsDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$KpiMetricsDtoImplCopyWith<_$KpiMetricsDtoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AgingAnalysisDto _$AgingAnalysisDtoFromJson(Map<String, dynamic> json) {
  return _AgingAnalysisDto.fromJson(json);
}

/// @nodoc
mixin _$AgingAnalysisDto {
  double get current => throw _privateConstructorUsedError;
  double get overdue30 => throw _privateConstructorUsedError;
  double get overdue60 => throw _privateConstructorUsedError;
  double get overdue90 => throw _privateConstructorUsedError;
  List<AgingTrendPointDto> get trend => throw _privateConstructorUsedError;

  /// Serializes this AgingAnalysisDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AgingAnalysisDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AgingAnalysisDtoCopyWith<AgingAnalysisDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AgingAnalysisDtoCopyWith<$Res> {
  factory $AgingAnalysisDtoCopyWith(
          AgingAnalysisDto value, $Res Function(AgingAnalysisDto) then) =
      _$AgingAnalysisDtoCopyWithImpl<$Res, AgingAnalysisDto>;
  @useResult
  $Res call(
      {double current,
      double overdue30,
      double overdue60,
      double overdue90,
      List<AgingTrendPointDto> trend});
}

/// @nodoc
class _$AgingAnalysisDtoCopyWithImpl<$Res, $Val extends AgingAnalysisDto>
    implements $AgingAnalysisDtoCopyWith<$Res> {
  _$AgingAnalysisDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AgingAnalysisDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? current = null,
    Object? overdue30 = null,
    Object? overdue60 = null,
    Object? overdue90 = null,
    Object? trend = null,
  }) {
    return _then(_value.copyWith(
      current: null == current
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as double,
      overdue30: null == overdue30
          ? _value.overdue30
          : overdue30 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue60: null == overdue60
          ? _value.overdue60
          : overdue60 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue90: null == overdue90
          ? _value.overdue90
          : overdue90 // ignore: cast_nullable_to_non_nullable
              as double,
      trend: null == trend
          ? _value.trend
          : trend // ignore: cast_nullable_to_non_nullable
              as List<AgingTrendPointDto>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AgingAnalysisDtoImplCopyWith<$Res>
    implements $AgingAnalysisDtoCopyWith<$Res> {
  factory _$$AgingAnalysisDtoImplCopyWith(_$AgingAnalysisDtoImpl value,
          $Res Function(_$AgingAnalysisDtoImpl) then) =
      __$$AgingAnalysisDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double current,
      double overdue30,
      double overdue60,
      double overdue90,
      List<AgingTrendPointDto> trend});
}

/// @nodoc
class __$$AgingAnalysisDtoImplCopyWithImpl<$Res>
    extends _$AgingAnalysisDtoCopyWithImpl<$Res, _$AgingAnalysisDtoImpl>
    implements _$$AgingAnalysisDtoImplCopyWith<$Res> {
  __$$AgingAnalysisDtoImplCopyWithImpl(_$AgingAnalysisDtoImpl _value,
      $Res Function(_$AgingAnalysisDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of AgingAnalysisDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? current = null,
    Object? overdue30 = null,
    Object? overdue60 = null,
    Object? overdue90 = null,
    Object? trend = null,
  }) {
    return _then(_$AgingAnalysisDtoImpl(
      current: null == current
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as double,
      overdue30: null == overdue30
          ? _value.overdue30
          : overdue30 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue60: null == overdue60
          ? _value.overdue60
          : overdue60 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue90: null == overdue90
          ? _value.overdue90
          : overdue90 // ignore: cast_nullable_to_non_nullable
              as double,
      trend: null == trend
          ? _value._trend
          : trend // ignore: cast_nullable_to_non_nullable
              as List<AgingTrendPointDto>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AgingAnalysisDtoImpl implements _AgingAnalysisDto {
  const _$AgingAnalysisDtoImpl(
      {this.current = 0.0,
      this.overdue30 = 0.0,
      this.overdue60 = 0.0,
      this.overdue90 = 0.0,
      final List<AgingTrendPointDto> trend = const []})
      : _trend = trend;

  factory _$AgingAnalysisDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$AgingAnalysisDtoImplFromJson(json);

  @override
  @JsonKey()
  final double current;
  @override
  @JsonKey()
  final double overdue30;
  @override
  @JsonKey()
  final double overdue60;
  @override
  @JsonKey()
  final double overdue90;
  final List<AgingTrendPointDto> _trend;
  @override
  @JsonKey()
  List<AgingTrendPointDto> get trend {
    if (_trend is EqualUnmodifiableListView) return _trend;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_trend);
  }

  @override
  String toString() {
    return 'AgingAnalysisDto(current: $current, overdue30: $overdue30, overdue60: $overdue60, overdue90: $overdue90, trend: $trend)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AgingAnalysisDtoImpl &&
            (identical(other.current, current) || other.current == current) &&
            (identical(other.overdue30, overdue30) ||
                other.overdue30 == overdue30) &&
            (identical(other.overdue60, overdue60) ||
                other.overdue60 == overdue60) &&
            (identical(other.overdue90, overdue90) ||
                other.overdue90 == overdue90) &&
            const DeepCollectionEquality().equals(other._trend, _trend));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, current, overdue30, overdue60,
      overdue90, const DeepCollectionEquality().hash(_trend));

  /// Create a copy of AgingAnalysisDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AgingAnalysisDtoImplCopyWith<_$AgingAnalysisDtoImpl> get copyWith =>
      __$$AgingAnalysisDtoImplCopyWithImpl<_$AgingAnalysisDtoImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AgingAnalysisDtoImplToJson(
      this,
    );
  }
}

abstract class _AgingAnalysisDto implements AgingAnalysisDto {
  const factory _AgingAnalysisDto(
      {final double current,
      final double overdue30,
      final double overdue60,
      final double overdue90,
      final List<AgingTrendPointDto> trend}) = _$AgingAnalysisDtoImpl;

  factory _AgingAnalysisDto.fromJson(Map<String, dynamic> json) =
      _$AgingAnalysisDtoImpl.fromJson;

  @override
  double get current;
  @override
  double get overdue30;
  @override
  double get overdue60;
  @override
  double get overdue90;
  @override
  List<AgingTrendPointDto> get trend;

  /// Create a copy of AgingAnalysisDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AgingAnalysisDtoImplCopyWith<_$AgingAnalysisDtoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AgingTrendPointDto _$AgingTrendPointDtoFromJson(Map<String, dynamic> json) {
  return _AgingTrendPointDto.fromJson(json);
}

/// @nodoc
mixin _$AgingTrendPointDto {
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  DateTime get date => throw _privateConstructorUsedError;
  double get current => throw _privateConstructorUsedError;
  double get overdue30 => throw _privateConstructorUsedError;
  double get overdue60 => throw _privateConstructorUsedError;
  double get overdue90 => throw _privateConstructorUsedError;

  /// Serializes this AgingTrendPointDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AgingTrendPointDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AgingTrendPointDtoCopyWith<AgingTrendPointDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AgingTrendPointDtoCopyWith<$Res> {
  factory $AgingTrendPointDtoCopyWith(
          AgingTrendPointDto value, $Res Function(AgingTrendPointDto) then) =
      _$AgingTrendPointDtoCopyWithImpl<$Res, AgingTrendPointDto>;
  @useResult
  $Res call(
      {@JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      DateTime date,
      double current,
      double overdue30,
      double overdue60,
      double overdue90});
}

/// @nodoc
class _$AgingTrendPointDtoCopyWithImpl<$Res, $Val extends AgingTrendPointDto>
    implements $AgingTrendPointDtoCopyWith<$Res> {
  _$AgingTrendPointDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AgingTrendPointDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? current = null,
    Object? overdue30 = null,
    Object? overdue60 = null,
    Object? overdue90 = null,
  }) {
    return _then(_value.copyWith(
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      current: null == current
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as double,
      overdue30: null == overdue30
          ? _value.overdue30
          : overdue30 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue60: null == overdue60
          ? _value.overdue60
          : overdue60 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue90: null == overdue90
          ? _value.overdue90
          : overdue90 // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AgingTrendPointDtoImplCopyWith<$Res>
    implements $AgingTrendPointDtoCopyWith<$Res> {
  factory _$$AgingTrendPointDtoImplCopyWith(_$AgingTrendPointDtoImpl value,
          $Res Function(_$AgingTrendPointDtoImpl) then) =
      __$$AgingTrendPointDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      DateTime date,
      double current,
      double overdue30,
      double overdue60,
      double overdue90});
}

/// @nodoc
class __$$AgingTrendPointDtoImplCopyWithImpl<$Res>
    extends _$AgingTrendPointDtoCopyWithImpl<$Res, _$AgingTrendPointDtoImpl>
    implements _$$AgingTrendPointDtoImplCopyWith<$Res> {
  __$$AgingTrendPointDtoImplCopyWithImpl(_$AgingTrendPointDtoImpl _value,
      $Res Function(_$AgingTrendPointDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of AgingTrendPointDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = null,
    Object? current = null,
    Object? overdue30 = null,
    Object? overdue60 = null,
    Object? overdue90 = null,
  }) {
    return _then(_$AgingTrendPointDtoImpl(
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
      current: null == current
          ? _value.current
          : current // ignore: cast_nullable_to_non_nullable
              as double,
      overdue30: null == overdue30
          ? _value.overdue30
          : overdue30 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue60: null == overdue60
          ? _value.overdue60
          : overdue60 // ignore: cast_nullable_to_non_nullable
              as double,
      overdue90: null == overdue90
          ? _value.overdue90
          : overdue90 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AgingTrendPointDtoImpl implements _AgingTrendPointDto {
  const _$AgingTrendPointDtoImpl(
      {@JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      required this.date,
      required this.current,
      required this.overdue30,
      required this.overdue60,
      required this.overdue90});

  factory _$AgingTrendPointDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$AgingTrendPointDtoImplFromJson(json);

  @override
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  final DateTime date;
  @override
  final double current;
  @override
  final double overdue30;
  @override
  final double overdue60;
  @override
  final double overdue90;

  @override
  String toString() {
    return 'AgingTrendPointDto(date: $date, current: $current, overdue30: $overdue30, overdue60: $overdue60, overdue90: $overdue90)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AgingTrendPointDtoImpl &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.current, current) || other.current == current) &&
            (identical(other.overdue30, overdue30) ||
                other.overdue30 == overdue30) &&
            (identical(other.overdue60, overdue60) ||
                other.overdue60 == overdue60) &&
            (identical(other.overdue90, overdue90) ||
                other.overdue90 == overdue90));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, date, current, overdue30, overdue60, overdue90);

  /// Create a copy of AgingTrendPointDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AgingTrendPointDtoImplCopyWith<_$AgingTrendPointDtoImpl> get copyWith =>
      __$$AgingTrendPointDtoImplCopyWithImpl<_$AgingTrendPointDtoImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AgingTrendPointDtoImplToJson(
      this,
    );
  }
}

abstract class _AgingTrendPointDto implements AgingTrendPointDto {
  const factory _AgingTrendPointDto(
      {@JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      required final DateTime date,
      required final double current,
      required final double overdue30,
      required final double overdue60,
      required final double overdue90}) = _$AgingTrendPointDtoImpl;

  factory _AgingTrendPointDto.fromJson(Map<String, dynamic> json) =
      _$AgingTrendPointDtoImpl.fromJson;

  @override
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  DateTime get date;
  @override
  double get current;
  @override
  double get overdue30;
  @override
  double get overdue60;
  @override
  double get overdue90;

  /// Create a copy of AgingTrendPointDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AgingTrendPointDtoImplCopyWith<_$AgingTrendPointDtoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CriticalAlertDto _$CriticalAlertDtoFromJson(Map<String, dynamic> json) {
  return _CriticalAlertDto.fromJson(json);
}

/// @nodoc
mixin _$CriticalAlertDto {
  String get id => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get message => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;
  String get severity => throw _privateConstructorUsedError;
  bool get isRead => throw _privateConstructorUsedError;
  @JsonKey(fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
  DateTime? get createdAt => throw _privateConstructorUsedError;

  /// Serializes this CriticalAlertDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CriticalAlertDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CriticalAlertDtoCopyWith<CriticalAlertDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CriticalAlertDtoCopyWith<$Res> {
  factory $CriticalAlertDtoCopyWith(
          CriticalAlertDto value, $Res Function(CriticalAlertDto) then) =
      _$CriticalAlertDtoCopyWithImpl<$Res, CriticalAlertDto>;
  @useResult
  $Res call(
      {String id,
      String type,
      String message,
      int count,
      String severity,
      bool isRead,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      DateTime? createdAt});
}

/// @nodoc
class _$CriticalAlertDtoCopyWithImpl<$Res, $Val extends CriticalAlertDto>
    implements $CriticalAlertDtoCopyWith<$Res> {
  _$CriticalAlertDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CriticalAlertDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? message = null,
    Object? count = null,
    Object? severity = null,
    Object? isRead = null,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      severity: null == severity
          ? _value.severity
          : severity // ignore: cast_nullable_to_non_nullable
              as String,
      isRead: null == isRead
          ? _value.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CriticalAlertDtoImplCopyWith<$Res>
    implements $CriticalAlertDtoCopyWith<$Res> {
  factory _$$CriticalAlertDtoImplCopyWith(_$CriticalAlertDtoImpl value,
          $Res Function(_$CriticalAlertDtoImpl) then) =
      __$$CriticalAlertDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String type,
      String message,
      int count,
      String severity,
      bool isRead,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      DateTime? createdAt});
}

/// @nodoc
class __$$CriticalAlertDtoImplCopyWithImpl<$Res>
    extends _$CriticalAlertDtoCopyWithImpl<$Res, _$CriticalAlertDtoImpl>
    implements _$$CriticalAlertDtoImplCopyWith<$Res> {
  __$$CriticalAlertDtoImplCopyWithImpl(_$CriticalAlertDtoImpl _value,
      $Res Function(_$CriticalAlertDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of CriticalAlertDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? message = null,
    Object? count = null,
    Object? severity = null,
    Object? isRead = null,
    Object? createdAt = freezed,
  }) {
    return _then(_$CriticalAlertDtoImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      severity: null == severity
          ? _value.severity
          : severity // ignore: cast_nullable_to_non_nullable
              as String,
      isRead: null == isRead
          ? _value.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CriticalAlertDtoImpl implements _CriticalAlertDto {
  const _$CriticalAlertDtoImpl(
      {required this.id,
      required this.type,
      required this.message,
      required this.count,
      required this.severity,
      this.isRead = false,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      this.createdAt});

  factory _$CriticalAlertDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$CriticalAlertDtoImplFromJson(json);

  @override
  final String id;
  @override
  final String type;
  @override
  final String message;
  @override
  final int count;
  @override
  final String severity;
  @override
  @JsonKey()
  final bool isRead;
  @override
  @JsonKey(fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
  final DateTime? createdAt;

  @override
  String toString() {
    return 'CriticalAlertDto(id: $id, type: $type, message: $message, count: $count, severity: $severity, isRead: $isRead, createdAt: $createdAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CriticalAlertDtoImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.severity, severity) ||
                other.severity == severity) &&
            (identical(other.isRead, isRead) || other.isRead == isRead) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, type, message, count, severity, isRead, createdAt);

  /// Create a copy of CriticalAlertDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CriticalAlertDtoImplCopyWith<_$CriticalAlertDtoImpl> get copyWith =>
      __$$CriticalAlertDtoImplCopyWithImpl<_$CriticalAlertDtoImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CriticalAlertDtoImplToJson(
      this,
    );
  }
}

abstract class _CriticalAlertDto implements CriticalAlertDto {
  const factory _CriticalAlertDto(
      {required final String id,
      required final String type,
      required final String message,
      required final int count,
      required final String severity,
      final bool isRead,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      final DateTime? createdAt}) = _$CriticalAlertDtoImpl;

  factory _CriticalAlertDto.fromJson(Map<String, dynamic> json) =
      _$CriticalAlertDtoImpl.fromJson;

  @override
  String get id;
  @override
  String get type;
  @override
  String get message;
  @override
  int get count;
  @override
  String get severity;
  @override
  bool get isRead;
  @override
  @JsonKey(fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
  DateTime? get createdAt;

  /// Create a copy of CriticalAlertDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CriticalAlertDtoImplCopyWith<_$CriticalAlertDtoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PrioritizedDebtDto _$PrioritizedDebtDtoFromJson(Map<String, dynamic> json) {
  return _PrioritizedDebtDto.fromJson(json);
}

/// @nodoc
mixin _$PrioritizedDebtDto {
  String get id => throw _privateConstructorUsedError;
  String get counterpartyId => throw _privateConstructorUsedError;
  String get counterpartyName => throw _privateConstructorUsedError;
  String get counterpartyType => throw _privateConstructorUsedError;
  double get amount => throw _privateConstructorUsedError;
  String get currency => throw _privateConstructorUsedError;
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  DateTime get dueDate => throw _privateConstructorUsedError;
  int get daysOverdue => throw _privateConstructorUsedError;
  String get riskCategory => throw _privateConstructorUsedError;
  double get priorityScore => throw _privateConstructorUsedError;
  @JsonKey(fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
  DateTime? get lastContactDate => throw _privateConstructorUsedError;
  String? get lastContactType => throw _privateConstructorUsedError;
  String? get paymentStatus => throw _privateConstructorUsedError;
  List<String> get suggestedActions => throw _privateConstructorUsedError;
  bool get hasPaymentPlan => throw _privateConstructorUsedError;
  bool get isDisputed => throw _privateConstructorUsedError;
  int get transactionCount => throw _privateConstructorUsedError;
  String? get linkedCompanyName => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// Serializes this PrioritizedDebtDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PrioritizedDebtDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PrioritizedDebtDtoCopyWith<PrioritizedDebtDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PrioritizedDebtDtoCopyWith<$Res> {
  factory $PrioritizedDebtDtoCopyWith(
          PrioritizedDebtDto value, $Res Function(PrioritizedDebtDto) then) =
      _$PrioritizedDebtDtoCopyWithImpl<$Res, PrioritizedDebtDto>;
  @useResult
  $Res call(
      {String id,
      String counterpartyId,
      String counterpartyName,
      String counterpartyType,
      double amount,
      String currency,
      @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      DateTime dueDate,
      int daysOverdue,
      String riskCategory,
      double priorityScore,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      DateTime? lastContactDate,
      String? lastContactType,
      String? paymentStatus,
      List<String> suggestedActions,
      bool hasPaymentPlan,
      bool isDisputed,
      int transactionCount,
      String? linkedCompanyName,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$PrioritizedDebtDtoCopyWithImpl<$Res, $Val extends PrioritizedDebtDto>
    implements $PrioritizedDebtDtoCopyWith<$Res> {
  _$PrioritizedDebtDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PrioritizedDebtDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? counterpartyId = null,
    Object? counterpartyName = null,
    Object? counterpartyType = null,
    Object? amount = null,
    Object? currency = null,
    Object? dueDate = null,
    Object? daysOverdue = null,
    Object? riskCategory = null,
    Object? priorityScore = null,
    Object? lastContactDate = freezed,
    Object? lastContactType = freezed,
    Object? paymentStatus = freezed,
    Object? suggestedActions = null,
    Object? hasPaymentPlan = null,
    Object? isDisputed = null,
    Object? transactionCount = null,
    Object? linkedCompanyName = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      counterpartyId: null == counterpartyId
          ? _value.counterpartyId
          : counterpartyId // ignore: cast_nullable_to_non_nullable
              as String,
      counterpartyName: null == counterpartyName
          ? _value.counterpartyName
          : counterpartyName // ignore: cast_nullable_to_non_nullable
              as String,
      counterpartyType: null == counterpartyType
          ? _value.counterpartyType
          : counterpartyType // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      dueDate: null == dueDate
          ? _value.dueDate
          : dueDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      daysOverdue: null == daysOverdue
          ? _value.daysOverdue
          : daysOverdue // ignore: cast_nullable_to_non_nullable
              as int,
      riskCategory: null == riskCategory
          ? _value.riskCategory
          : riskCategory // ignore: cast_nullable_to_non_nullable
              as String,
      priorityScore: null == priorityScore
          ? _value.priorityScore
          : priorityScore // ignore: cast_nullable_to_non_nullable
              as double,
      lastContactDate: freezed == lastContactDate
          ? _value.lastContactDate
          : lastContactDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastContactType: freezed == lastContactType
          ? _value.lastContactType
          : lastContactType // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentStatus: freezed == paymentStatus
          ? _value.paymentStatus
          : paymentStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      suggestedActions: null == suggestedActions
          ? _value.suggestedActions
          : suggestedActions // ignore: cast_nullable_to_non_nullable
              as List<String>,
      hasPaymentPlan: null == hasPaymentPlan
          ? _value.hasPaymentPlan
          : hasPaymentPlan // ignore: cast_nullable_to_non_nullable
              as bool,
      isDisputed: null == isDisputed
          ? _value.isDisputed
          : isDisputed // ignore: cast_nullable_to_non_nullable
              as bool,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
      linkedCompanyName: freezed == linkedCompanyName
          ? _value.linkedCompanyName
          : linkedCompanyName // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PrioritizedDebtDtoImplCopyWith<$Res>
    implements $PrioritizedDebtDtoCopyWith<$Res> {
  factory _$$PrioritizedDebtDtoImplCopyWith(_$PrioritizedDebtDtoImpl value,
          $Res Function(_$PrioritizedDebtDtoImpl) then) =
      __$$PrioritizedDebtDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String counterpartyId,
      String counterpartyName,
      String counterpartyType,
      double amount,
      String currency,
      @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      DateTime dueDate,
      int daysOverdue,
      String riskCategory,
      double priorityScore,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      DateTime? lastContactDate,
      String? lastContactType,
      String? paymentStatus,
      List<String> suggestedActions,
      bool hasPaymentPlan,
      bool isDisputed,
      int transactionCount,
      String? linkedCompanyName,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$PrioritizedDebtDtoImplCopyWithImpl<$Res>
    extends _$PrioritizedDebtDtoCopyWithImpl<$Res, _$PrioritizedDebtDtoImpl>
    implements _$$PrioritizedDebtDtoImplCopyWith<$Res> {
  __$$PrioritizedDebtDtoImplCopyWithImpl(_$PrioritizedDebtDtoImpl _value,
      $Res Function(_$PrioritizedDebtDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of PrioritizedDebtDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? counterpartyId = null,
    Object? counterpartyName = null,
    Object? counterpartyType = null,
    Object? amount = null,
    Object? currency = null,
    Object? dueDate = null,
    Object? daysOverdue = null,
    Object? riskCategory = null,
    Object? priorityScore = null,
    Object? lastContactDate = freezed,
    Object? lastContactType = freezed,
    Object? paymentStatus = freezed,
    Object? suggestedActions = null,
    Object? hasPaymentPlan = null,
    Object? isDisputed = null,
    Object? transactionCount = null,
    Object? linkedCompanyName = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$PrioritizedDebtDtoImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      counterpartyId: null == counterpartyId
          ? _value.counterpartyId
          : counterpartyId // ignore: cast_nullable_to_non_nullable
              as String,
      counterpartyName: null == counterpartyName
          ? _value.counterpartyName
          : counterpartyName // ignore: cast_nullable_to_non_nullable
              as String,
      counterpartyType: null == counterpartyType
          ? _value.counterpartyType
          : counterpartyType // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      dueDate: null == dueDate
          ? _value.dueDate
          : dueDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      daysOverdue: null == daysOverdue
          ? _value.daysOverdue
          : daysOverdue // ignore: cast_nullable_to_non_nullable
              as int,
      riskCategory: null == riskCategory
          ? _value.riskCategory
          : riskCategory // ignore: cast_nullable_to_non_nullable
              as String,
      priorityScore: null == priorityScore
          ? _value.priorityScore
          : priorityScore // ignore: cast_nullable_to_non_nullable
              as double,
      lastContactDate: freezed == lastContactDate
          ? _value.lastContactDate
          : lastContactDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastContactType: freezed == lastContactType
          ? _value.lastContactType
          : lastContactType // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentStatus: freezed == paymentStatus
          ? _value.paymentStatus
          : paymentStatus // ignore: cast_nullable_to_non_nullable
              as String?,
      suggestedActions: null == suggestedActions
          ? _value._suggestedActions
          : suggestedActions // ignore: cast_nullable_to_non_nullable
              as List<String>,
      hasPaymentPlan: null == hasPaymentPlan
          ? _value.hasPaymentPlan
          : hasPaymentPlan // ignore: cast_nullable_to_non_nullable
              as bool,
      isDisputed: null == isDisputed
          ? _value.isDisputed
          : isDisputed // ignore: cast_nullable_to_non_nullable
              as bool,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
      linkedCompanyName: freezed == linkedCompanyName
          ? _value.linkedCompanyName
          : linkedCompanyName // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PrioritizedDebtDtoImpl implements _PrioritizedDebtDto {
  const _$PrioritizedDebtDtoImpl(
      {required this.id,
      required this.counterpartyId,
      required this.counterpartyName,
      required this.counterpartyType,
      required this.amount,
      required this.currency,
      @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      required this.dueDate,
      required this.daysOverdue,
      required this.riskCategory,
      required this.priorityScore,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      this.lastContactDate,
      this.lastContactType,
      this.paymentStatus,
      final List<String> suggestedActions = const [],
      this.hasPaymentPlan = false,
      this.isDisputed = false,
      this.transactionCount = 0,
      this.linkedCompanyName,
      final Map<String, dynamic>? metadata})
      : _suggestedActions = suggestedActions,
        _metadata = metadata;

  factory _$PrioritizedDebtDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$PrioritizedDebtDtoImplFromJson(json);

  @override
  final String id;
  @override
  final String counterpartyId;
  @override
  final String counterpartyName;
  @override
  final String counterpartyType;
  @override
  final double amount;
  @override
  final String currency;
  @override
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  final DateTime dueDate;
  @override
  final int daysOverdue;
  @override
  final String riskCategory;
  @override
  final double priorityScore;
  @override
  @JsonKey(fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
  final DateTime? lastContactDate;
  @override
  final String? lastContactType;
  @override
  final String? paymentStatus;
  final List<String> _suggestedActions;
  @override
  @JsonKey()
  List<String> get suggestedActions {
    if (_suggestedActions is EqualUnmodifiableListView)
      return _suggestedActions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_suggestedActions);
  }

  @override
  @JsonKey()
  final bool hasPaymentPlan;
  @override
  @JsonKey()
  final bool isDisputed;
  @override
  @JsonKey()
  final int transactionCount;
  @override
  final String? linkedCompanyName;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'PrioritizedDebtDto(id: $id, counterpartyId: $counterpartyId, counterpartyName: $counterpartyName, counterpartyType: $counterpartyType, amount: $amount, currency: $currency, dueDate: $dueDate, daysOverdue: $daysOverdue, riskCategory: $riskCategory, priorityScore: $priorityScore, lastContactDate: $lastContactDate, lastContactType: $lastContactType, paymentStatus: $paymentStatus, suggestedActions: $suggestedActions, hasPaymentPlan: $hasPaymentPlan, isDisputed: $isDisputed, transactionCount: $transactionCount, linkedCompanyName: $linkedCompanyName, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PrioritizedDebtDtoImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.counterpartyId, counterpartyId) ||
                other.counterpartyId == counterpartyId) &&
            (identical(other.counterpartyName, counterpartyName) ||
                other.counterpartyName == counterpartyName) &&
            (identical(other.counterpartyType, counterpartyType) ||
                other.counterpartyType == counterpartyType) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.dueDate, dueDate) || other.dueDate == dueDate) &&
            (identical(other.daysOverdue, daysOverdue) ||
                other.daysOverdue == daysOverdue) &&
            (identical(other.riskCategory, riskCategory) ||
                other.riskCategory == riskCategory) &&
            (identical(other.priorityScore, priorityScore) ||
                other.priorityScore == priorityScore) &&
            (identical(other.lastContactDate, lastContactDate) ||
                other.lastContactDate == lastContactDate) &&
            (identical(other.lastContactType, lastContactType) ||
                other.lastContactType == lastContactType) &&
            (identical(other.paymentStatus, paymentStatus) ||
                other.paymentStatus == paymentStatus) &&
            const DeepCollectionEquality()
                .equals(other._suggestedActions, _suggestedActions) &&
            (identical(other.hasPaymentPlan, hasPaymentPlan) ||
                other.hasPaymentPlan == hasPaymentPlan) &&
            (identical(other.isDisputed, isDisputed) ||
                other.isDisputed == isDisputed) &&
            (identical(other.transactionCount, transactionCount) ||
                other.transactionCount == transactionCount) &&
            (identical(other.linkedCompanyName, linkedCompanyName) ||
                other.linkedCompanyName == linkedCompanyName) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        counterpartyId,
        counterpartyName,
        counterpartyType,
        amount,
        currency,
        dueDate,
        daysOverdue,
        riskCategory,
        priorityScore,
        lastContactDate,
        lastContactType,
        paymentStatus,
        const DeepCollectionEquality().hash(_suggestedActions),
        hasPaymentPlan,
        isDisputed,
        transactionCount,
        linkedCompanyName,
        const DeepCollectionEquality().hash(_metadata)
      ]);

  /// Create a copy of PrioritizedDebtDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PrioritizedDebtDtoImplCopyWith<_$PrioritizedDebtDtoImpl> get copyWith =>
      __$$PrioritizedDebtDtoImplCopyWithImpl<_$PrioritizedDebtDtoImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PrioritizedDebtDtoImplToJson(
      this,
    );
  }
}

abstract class _PrioritizedDebtDto implements PrioritizedDebtDto {
  const factory _PrioritizedDebtDto(
      {required final String id,
      required final String counterpartyId,
      required final String counterpartyName,
      required final String counterpartyType,
      required final double amount,
      required final String currency,
      @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
      required final DateTime dueDate,
      required final int daysOverdue,
      required final String riskCategory,
      required final double priorityScore,
      @JsonKey(
          fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
      final DateTime? lastContactDate,
      final String? lastContactType,
      final String? paymentStatus,
      final List<String> suggestedActions,
      final bool hasPaymentPlan,
      final bool isDisputed,
      final int transactionCount,
      final String? linkedCompanyName,
      final Map<String, dynamic>? metadata}) = _$PrioritizedDebtDtoImpl;

  factory _PrioritizedDebtDto.fromJson(Map<String, dynamic> json) =
      _$PrioritizedDebtDtoImpl.fromJson;

  @override
  String get id;
  @override
  String get counterpartyId;
  @override
  String get counterpartyName;
  @override
  String get counterpartyType;
  @override
  double get amount;
  @override
  String get currency;
  @override
  @JsonKey(fromJson: _dateTimeFromJson, toJson: _dateTimeToJson)
  DateTime get dueDate;
  @override
  int get daysOverdue;
  @override
  String get riskCategory;
  @override
  double get priorityScore;
  @override
  @JsonKey(fromJson: _dateTimeFromJsonNullable, toJson: _dateTimeToJsonNullable)
  DateTime? get lastContactDate;
  @override
  String? get lastContactType;
  @override
  String? get paymentStatus;
  @override
  List<String> get suggestedActions;
  @override
  bool get hasPaymentPlan;
  @override
  bool get isDisputed;
  @override
  int get transactionCount;
  @override
  String? get linkedCompanyName;
  @override
  Map<String, dynamic>? get metadata;

  /// Create a copy of PrioritizedDebtDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PrioritizedDebtDtoImplCopyWith<_$PrioritizedDebtDtoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PerspectiveSummaryDto _$PerspectiveSummaryDtoFromJson(
    Map<String, dynamic> json) {
  return _PerspectiveSummaryDto.fromJson(json);
}

/// @nodoc
mixin _$PerspectiveSummaryDto {
  String get perspectiveType => throw _privateConstructorUsedError;
  String get entityId => throw _privateConstructorUsedError;
  String get entityName => throw _privateConstructorUsedError;
  double get totalReceivable => throw _privateConstructorUsedError;
  double get totalPayable => throw _privateConstructorUsedError;
  double get netPosition => throw _privateConstructorUsedError;
  double get internalReceivable => throw _privateConstructorUsedError;
  double get internalPayable => throw _privateConstructorUsedError;
  double get internalNetPosition => throw _privateConstructorUsedError;
  double get externalReceivable => throw _privateConstructorUsedError;
  double get externalPayable => throw _privateConstructorUsedError;
  double get externalNetPosition => throw _privateConstructorUsedError;
  List<StoreAggregateDto> get storeAggregates =>
      throw _privateConstructorUsedError;
  int get counterpartyCount => throw _privateConstructorUsedError;
  int get transactionCount => throw _privateConstructorUsedError;
  double get collectionRate => throw _privateConstructorUsedError;
  int get criticalCount => throw _privateConstructorUsedError;

  /// Serializes this PerspectiveSummaryDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PerspectiveSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PerspectiveSummaryDtoCopyWith<PerspectiveSummaryDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PerspectiveSummaryDtoCopyWith<$Res> {
  factory $PerspectiveSummaryDtoCopyWith(PerspectiveSummaryDto value,
          $Res Function(PerspectiveSummaryDto) then) =
      _$PerspectiveSummaryDtoCopyWithImpl<$Res, PerspectiveSummaryDto>;
  @useResult
  $Res call(
      {String perspectiveType,
      String entityId,
      String entityName,
      double totalReceivable,
      double totalPayable,
      double netPosition,
      double internalReceivable,
      double internalPayable,
      double internalNetPosition,
      double externalReceivable,
      double externalPayable,
      double externalNetPosition,
      List<StoreAggregateDto> storeAggregates,
      int counterpartyCount,
      int transactionCount,
      double collectionRate,
      int criticalCount});
}

/// @nodoc
class _$PerspectiveSummaryDtoCopyWithImpl<$Res,
        $Val extends PerspectiveSummaryDto>
    implements $PerspectiveSummaryDtoCopyWith<$Res> {
  _$PerspectiveSummaryDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PerspectiveSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? perspectiveType = null,
    Object? entityId = null,
    Object? entityName = null,
    Object? totalReceivable = null,
    Object? totalPayable = null,
    Object? netPosition = null,
    Object? internalReceivable = null,
    Object? internalPayable = null,
    Object? internalNetPosition = null,
    Object? externalReceivable = null,
    Object? externalPayable = null,
    Object? externalNetPosition = null,
    Object? storeAggregates = null,
    Object? counterpartyCount = null,
    Object? transactionCount = null,
    Object? collectionRate = null,
    Object? criticalCount = null,
  }) {
    return _then(_value.copyWith(
      perspectiveType: null == perspectiveType
          ? _value.perspectiveType
          : perspectiveType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _value.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      entityName: null == entityName
          ? _value.entityName
          : entityName // ignore: cast_nullable_to_non_nullable
              as String,
      totalReceivable: null == totalReceivable
          ? _value.totalReceivable
          : totalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      totalPayable: null == totalPayable
          ? _value.totalPayable
          : totalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      internalReceivable: null == internalReceivable
          ? _value.internalReceivable
          : internalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      internalPayable: null == internalPayable
          ? _value.internalPayable
          : internalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      internalNetPosition: null == internalNetPosition
          ? _value.internalNetPosition
          : internalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      externalReceivable: null == externalReceivable
          ? _value.externalReceivable
          : externalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      externalPayable: null == externalPayable
          ? _value.externalPayable
          : externalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      externalNetPosition: null == externalNetPosition
          ? _value.externalNetPosition
          : externalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      storeAggregates: null == storeAggregates
          ? _value.storeAggregates
          : storeAggregates // ignore: cast_nullable_to_non_nullable
              as List<StoreAggregateDto>,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
      collectionRate: null == collectionRate
          ? _value.collectionRate
          : collectionRate // ignore: cast_nullable_to_non_nullable
              as double,
      criticalCount: null == criticalCount
          ? _value.criticalCount
          : criticalCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PerspectiveSummaryDtoImplCopyWith<$Res>
    implements $PerspectiveSummaryDtoCopyWith<$Res> {
  factory _$$PerspectiveSummaryDtoImplCopyWith(
          _$PerspectiveSummaryDtoImpl value,
          $Res Function(_$PerspectiveSummaryDtoImpl) then) =
      __$$PerspectiveSummaryDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String perspectiveType,
      String entityId,
      String entityName,
      double totalReceivable,
      double totalPayable,
      double netPosition,
      double internalReceivable,
      double internalPayable,
      double internalNetPosition,
      double externalReceivable,
      double externalPayable,
      double externalNetPosition,
      List<StoreAggregateDto> storeAggregates,
      int counterpartyCount,
      int transactionCount,
      double collectionRate,
      int criticalCount});
}

/// @nodoc
class __$$PerspectiveSummaryDtoImplCopyWithImpl<$Res>
    extends _$PerspectiveSummaryDtoCopyWithImpl<$Res,
        _$PerspectiveSummaryDtoImpl>
    implements _$$PerspectiveSummaryDtoImplCopyWith<$Res> {
  __$$PerspectiveSummaryDtoImplCopyWithImpl(_$PerspectiveSummaryDtoImpl _value,
      $Res Function(_$PerspectiveSummaryDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of PerspectiveSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? perspectiveType = null,
    Object? entityId = null,
    Object? entityName = null,
    Object? totalReceivable = null,
    Object? totalPayable = null,
    Object? netPosition = null,
    Object? internalReceivable = null,
    Object? internalPayable = null,
    Object? internalNetPosition = null,
    Object? externalReceivable = null,
    Object? externalPayable = null,
    Object? externalNetPosition = null,
    Object? storeAggregates = null,
    Object? counterpartyCount = null,
    Object? transactionCount = null,
    Object? collectionRate = null,
    Object? criticalCount = null,
  }) {
    return _then(_$PerspectiveSummaryDtoImpl(
      perspectiveType: null == perspectiveType
          ? _value.perspectiveType
          : perspectiveType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _value.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      entityName: null == entityName
          ? _value.entityName
          : entityName // ignore: cast_nullable_to_non_nullable
              as String,
      totalReceivable: null == totalReceivable
          ? _value.totalReceivable
          : totalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      totalPayable: null == totalPayable
          ? _value.totalPayable
          : totalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      internalReceivable: null == internalReceivable
          ? _value.internalReceivable
          : internalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      internalPayable: null == internalPayable
          ? _value.internalPayable
          : internalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      internalNetPosition: null == internalNetPosition
          ? _value.internalNetPosition
          : internalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      externalReceivable: null == externalReceivable
          ? _value.externalReceivable
          : externalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      externalPayable: null == externalPayable
          ? _value.externalPayable
          : externalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      externalNetPosition: null == externalNetPosition
          ? _value.externalNetPosition
          : externalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      storeAggregates: null == storeAggregates
          ? _value._storeAggregates
          : storeAggregates // ignore: cast_nullable_to_non_nullable
              as List<StoreAggregateDto>,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
      collectionRate: null == collectionRate
          ? _value.collectionRate
          : collectionRate // ignore: cast_nullable_to_non_nullable
              as double,
      criticalCount: null == criticalCount
          ? _value.criticalCount
          : criticalCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PerspectiveSummaryDtoImpl implements _PerspectiveSummaryDto {
  const _$PerspectiveSummaryDtoImpl(
      {required this.perspectiveType,
      required this.entityId,
      required this.entityName,
      required this.totalReceivable,
      required this.totalPayable,
      required this.netPosition,
      required this.internalReceivable,
      required this.internalPayable,
      required this.internalNetPosition,
      required this.externalReceivable,
      required this.externalPayable,
      required this.externalNetPosition,
      final List<StoreAggregateDto> storeAggregates = const [],
      required this.counterpartyCount,
      required this.transactionCount,
      required this.collectionRate,
      required this.criticalCount})
      : _storeAggregates = storeAggregates;

  factory _$PerspectiveSummaryDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$PerspectiveSummaryDtoImplFromJson(json);

  @override
  final String perspectiveType;
  @override
  final String entityId;
  @override
  final String entityName;
  @override
  final double totalReceivable;
  @override
  final double totalPayable;
  @override
  final double netPosition;
  @override
  final double internalReceivable;
  @override
  final double internalPayable;
  @override
  final double internalNetPosition;
  @override
  final double externalReceivable;
  @override
  final double externalPayable;
  @override
  final double externalNetPosition;
  final List<StoreAggregateDto> _storeAggregates;
  @override
  @JsonKey()
  List<StoreAggregateDto> get storeAggregates {
    if (_storeAggregates is EqualUnmodifiableListView) return _storeAggregates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_storeAggregates);
  }

  @override
  final int counterpartyCount;
  @override
  final int transactionCount;
  @override
  final double collectionRate;
  @override
  final int criticalCount;

  @override
  String toString() {
    return 'PerspectiveSummaryDto(perspectiveType: $perspectiveType, entityId: $entityId, entityName: $entityName, totalReceivable: $totalReceivable, totalPayable: $totalPayable, netPosition: $netPosition, internalReceivable: $internalReceivable, internalPayable: $internalPayable, internalNetPosition: $internalNetPosition, externalReceivable: $externalReceivable, externalPayable: $externalPayable, externalNetPosition: $externalNetPosition, storeAggregates: $storeAggregates, counterpartyCount: $counterpartyCount, transactionCount: $transactionCount, collectionRate: $collectionRate, criticalCount: $criticalCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PerspectiveSummaryDtoImpl &&
            (identical(other.perspectiveType, perspectiveType) ||
                other.perspectiveType == perspectiveType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.entityName, entityName) ||
                other.entityName == entityName) &&
            (identical(other.totalReceivable, totalReceivable) ||
                other.totalReceivable == totalReceivable) &&
            (identical(other.totalPayable, totalPayable) ||
                other.totalPayable == totalPayable) &&
            (identical(other.netPosition, netPosition) ||
                other.netPosition == netPosition) &&
            (identical(other.internalReceivable, internalReceivable) ||
                other.internalReceivable == internalReceivable) &&
            (identical(other.internalPayable, internalPayable) ||
                other.internalPayable == internalPayable) &&
            (identical(other.internalNetPosition, internalNetPosition) ||
                other.internalNetPosition == internalNetPosition) &&
            (identical(other.externalReceivable, externalReceivable) ||
                other.externalReceivable == externalReceivable) &&
            (identical(other.externalPayable, externalPayable) ||
                other.externalPayable == externalPayable) &&
            (identical(other.externalNetPosition, externalNetPosition) ||
                other.externalNetPosition == externalNetPosition) &&
            const DeepCollectionEquality()
                .equals(other._storeAggregates, _storeAggregates) &&
            (identical(other.counterpartyCount, counterpartyCount) ||
                other.counterpartyCount == counterpartyCount) &&
            (identical(other.transactionCount, transactionCount) ||
                other.transactionCount == transactionCount) &&
            (identical(other.collectionRate, collectionRate) ||
                other.collectionRate == collectionRate) &&
            (identical(other.criticalCount, criticalCount) ||
                other.criticalCount == criticalCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      perspectiveType,
      entityId,
      entityName,
      totalReceivable,
      totalPayable,
      netPosition,
      internalReceivable,
      internalPayable,
      internalNetPosition,
      externalReceivable,
      externalPayable,
      externalNetPosition,
      const DeepCollectionEquality().hash(_storeAggregates),
      counterpartyCount,
      transactionCount,
      collectionRate,
      criticalCount);

  /// Create a copy of PerspectiveSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PerspectiveSummaryDtoImplCopyWith<_$PerspectiveSummaryDtoImpl>
      get copyWith => __$$PerspectiveSummaryDtoImplCopyWithImpl<
          _$PerspectiveSummaryDtoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PerspectiveSummaryDtoImplToJson(
      this,
    );
  }
}

abstract class _PerspectiveSummaryDto implements PerspectiveSummaryDto {
  const factory _PerspectiveSummaryDto(
      {required final String perspectiveType,
      required final String entityId,
      required final String entityName,
      required final double totalReceivable,
      required final double totalPayable,
      required final double netPosition,
      required final double internalReceivable,
      required final double internalPayable,
      required final double internalNetPosition,
      required final double externalReceivable,
      required final double externalPayable,
      required final double externalNetPosition,
      final List<StoreAggregateDto> storeAggregates,
      required final int counterpartyCount,
      required final int transactionCount,
      required final double collectionRate,
      required final int criticalCount}) = _$PerspectiveSummaryDtoImpl;

  factory _PerspectiveSummaryDto.fromJson(Map<String, dynamic> json) =
      _$PerspectiveSummaryDtoImpl.fromJson;

  @override
  String get perspectiveType;
  @override
  String get entityId;
  @override
  String get entityName;
  @override
  double get totalReceivable;
  @override
  double get totalPayable;
  @override
  double get netPosition;
  @override
  double get internalReceivable;
  @override
  double get internalPayable;
  @override
  double get internalNetPosition;
  @override
  double get externalReceivable;
  @override
  double get externalPayable;
  @override
  double get externalNetPosition;
  @override
  List<StoreAggregateDto> get storeAggregates;
  @override
  int get counterpartyCount;
  @override
  int get transactionCount;
  @override
  double get collectionRate;
  @override
  int get criticalCount;

  /// Create a copy of PerspectiveSummaryDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PerspectiveSummaryDtoImplCopyWith<_$PerspectiveSummaryDtoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

StoreAggregateDto _$StoreAggregateDtoFromJson(Map<String, dynamic> json) {
  return _StoreAggregateDto.fromJson(json);
}

/// @nodoc
mixin _$StoreAggregateDto {
  String get storeId => throw _privateConstructorUsedError;
  String get storeName => throw _privateConstructorUsedError;
  double get receivable => throw _privateConstructorUsedError;
  double get payable => throw _privateConstructorUsedError;
  double get netPosition => throw _privateConstructorUsedError;
  int get counterpartyCount => throw _privateConstructorUsedError;
  bool get isHeadquarters => throw _privateConstructorUsedError;

  /// Serializes this StoreAggregateDto to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of StoreAggregateDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoreAggregateDtoCopyWith<StoreAggregateDto> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoreAggregateDtoCopyWith<$Res> {
  factory $StoreAggregateDtoCopyWith(
          StoreAggregateDto value, $Res Function(StoreAggregateDto) then) =
      _$StoreAggregateDtoCopyWithImpl<$Res, StoreAggregateDto>;
  @useResult
  $Res call(
      {String storeId,
      String storeName,
      double receivable,
      double payable,
      double netPosition,
      int counterpartyCount,
      bool isHeadquarters});
}

/// @nodoc
class _$StoreAggregateDtoCopyWithImpl<$Res, $Val extends StoreAggregateDto>
    implements $StoreAggregateDtoCopyWith<$Res> {
  _$StoreAggregateDtoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StoreAggregateDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? storeId = null,
    Object? storeName = null,
    Object? receivable = null,
    Object? payable = null,
    Object? netPosition = null,
    Object? counterpartyCount = null,
    Object? isHeadquarters = null,
  }) {
    return _then(_value.copyWith(
      storeId: null == storeId
          ? _value.storeId
          : storeId // ignore: cast_nullable_to_non_nullable
              as String,
      storeName: null == storeName
          ? _value.storeName
          : storeName // ignore: cast_nullable_to_non_nullable
              as String,
      receivable: null == receivable
          ? _value.receivable
          : receivable // ignore: cast_nullable_to_non_nullable
              as double,
      payable: null == payable
          ? _value.payable
          : payable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      isHeadquarters: null == isHeadquarters
          ? _value.isHeadquarters
          : isHeadquarters // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StoreAggregateDtoImplCopyWith<$Res>
    implements $StoreAggregateDtoCopyWith<$Res> {
  factory _$$StoreAggregateDtoImplCopyWith(_$StoreAggregateDtoImpl value,
          $Res Function(_$StoreAggregateDtoImpl) then) =
      __$$StoreAggregateDtoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String storeId,
      String storeName,
      double receivable,
      double payable,
      double netPosition,
      int counterpartyCount,
      bool isHeadquarters});
}

/// @nodoc
class __$$StoreAggregateDtoImplCopyWithImpl<$Res>
    extends _$StoreAggregateDtoCopyWithImpl<$Res, _$StoreAggregateDtoImpl>
    implements _$$StoreAggregateDtoImplCopyWith<$Res> {
  __$$StoreAggregateDtoImplCopyWithImpl(_$StoreAggregateDtoImpl _value,
      $Res Function(_$StoreAggregateDtoImpl) _then)
      : super(_value, _then);

  /// Create a copy of StoreAggregateDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? storeId = null,
    Object? storeName = null,
    Object? receivable = null,
    Object? payable = null,
    Object? netPosition = null,
    Object? counterpartyCount = null,
    Object? isHeadquarters = null,
  }) {
    return _then(_$StoreAggregateDtoImpl(
      storeId: null == storeId
          ? _value.storeId
          : storeId // ignore: cast_nullable_to_non_nullable
              as String,
      storeName: null == storeName
          ? _value.storeName
          : storeName // ignore: cast_nullable_to_non_nullable
              as String,
      receivable: null == receivable
          ? _value.receivable
          : receivable // ignore: cast_nullable_to_non_nullable
              as double,
      payable: null == payable
          ? _value.payable
          : payable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      isHeadquarters: null == isHeadquarters
          ? _value.isHeadquarters
          : isHeadquarters // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StoreAggregateDtoImpl implements _StoreAggregateDto {
  const _$StoreAggregateDtoImpl(
      {required this.storeId,
      required this.storeName,
      required this.receivable,
      required this.payable,
      required this.netPosition,
      required this.counterpartyCount,
      required this.isHeadquarters});

  factory _$StoreAggregateDtoImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoreAggregateDtoImplFromJson(json);

  @override
  final String storeId;
  @override
  final String storeName;
  @override
  final double receivable;
  @override
  final double payable;
  @override
  final double netPosition;
  @override
  final int counterpartyCount;
  @override
  final bool isHeadquarters;

  @override
  String toString() {
    return 'StoreAggregateDto(storeId: $storeId, storeName: $storeName, receivable: $receivable, payable: $payable, netPosition: $netPosition, counterpartyCount: $counterpartyCount, isHeadquarters: $isHeadquarters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoreAggregateDtoImpl &&
            (identical(other.storeId, storeId) || other.storeId == storeId) &&
            (identical(other.storeName, storeName) ||
                other.storeName == storeName) &&
            (identical(other.receivable, receivable) ||
                other.receivable == receivable) &&
            (identical(other.payable, payable) || other.payable == payable) &&
            (identical(other.netPosition, netPosition) ||
                other.netPosition == netPosition) &&
            (identical(other.counterpartyCount, counterpartyCount) ||
                other.counterpartyCount == counterpartyCount) &&
            (identical(other.isHeadquarters, isHeadquarters) ||
                other.isHeadquarters == isHeadquarters));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, storeId, storeName, receivable,
      payable, netPosition, counterpartyCount, isHeadquarters);

  /// Create a copy of StoreAggregateDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoreAggregateDtoImplCopyWith<_$StoreAggregateDtoImpl> get copyWith =>
      __$$StoreAggregateDtoImplCopyWithImpl<_$StoreAggregateDtoImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StoreAggregateDtoImplToJson(
      this,
    );
  }
}

abstract class _StoreAggregateDto implements StoreAggregateDto {
  const factory _StoreAggregateDto(
      {required final String storeId,
      required final String storeName,
      required final double receivable,
      required final double payable,
      required final double netPosition,
      required final int counterpartyCount,
      required final bool isHeadquarters}) = _$StoreAggregateDtoImpl;

  factory _StoreAggregateDto.fromJson(Map<String, dynamic> json) =
      _$StoreAggregateDtoImpl.fromJson;

  @override
  String get storeId;
  @override
  String get storeName;
  @override
  double get receivable;
  @override
  double get payable;
  @override
  double get netPosition;
  @override
  int get counterpartyCount;
  @override
  bool get isHeadquarters;

  /// Create a copy of StoreAggregateDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoreAggregateDtoImplCopyWith<_$StoreAggregateDtoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
