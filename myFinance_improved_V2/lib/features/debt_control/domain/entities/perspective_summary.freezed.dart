// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'perspective_summary.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PerspectiveSummary {
  String get perspectiveType => throw _privateConstructorUsedError;
  String get entityId => throw _privateConstructorUsedError;
  String get entityName => throw _privateConstructorUsedError;
  double get totalReceivable => throw _privateConstructorUsedError;
  double get totalPayable => throw _privateConstructorUsedError;
  double get netPosition => throw _privateConstructorUsedError;
  double get internalReceivable => throw _privateConstructorUsedError;
  double get internalPayable => throw _privateConstructorUsedError;
  double get internalNetPosition => throw _privateConstructorUsedError;
  double get externalReceivable => throw _privateConstructorUsedError;
  double get externalPayable => throw _privateConstructorUsedError;
  double get externalNetPosition => throw _privateConstructorUsedError;
  List<StoreAggregate> get storeAggregates =>
      throw _privateConstructorUsedError;
  int get counterpartyCount => throw _privateConstructorUsedError;
  int get transactionCount => throw _privateConstructorUsedError;
  double get collectionRate => throw _privateConstructorUsedError;
  int get criticalCount => throw _privateConstructorUsedError;

  /// Create a copy of PerspectiveSummary
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PerspectiveSummaryCopyWith<PerspectiveSummary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PerspectiveSummaryCopyWith<$Res> {
  factory $PerspectiveSummaryCopyWith(
          PerspectiveSummary value, $Res Function(PerspectiveSummary) then) =
      _$PerspectiveSummaryCopyWithImpl<$Res, PerspectiveSummary>;
  @useResult
  $Res call(
      {String perspectiveType,
      String entityId,
      String entityName,
      double totalReceivable,
      double totalPayable,
      double netPosition,
      double internalReceivable,
      double internalPayable,
      double internalNetPosition,
      double externalReceivable,
      double externalPayable,
      double externalNetPosition,
      List<StoreAggregate> storeAggregates,
      int counterpartyCount,
      int transactionCount,
      double collectionRate,
      int criticalCount});
}

/// @nodoc
class _$PerspectiveSummaryCopyWithImpl<$Res, $Val extends PerspectiveSummary>
    implements $PerspectiveSummaryCopyWith<$Res> {
  _$PerspectiveSummaryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PerspectiveSummary
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? perspectiveType = null,
    Object? entityId = null,
    Object? entityName = null,
    Object? totalReceivable = null,
    Object? totalPayable = null,
    Object? netPosition = null,
    Object? internalReceivable = null,
    Object? internalPayable = null,
    Object? internalNetPosition = null,
    Object? externalReceivable = null,
    Object? externalPayable = null,
    Object? externalNetPosition = null,
    Object? storeAggregates = null,
    Object? counterpartyCount = null,
    Object? transactionCount = null,
    Object? collectionRate = null,
    Object? criticalCount = null,
  }) {
    return _then(_value.copyWith(
      perspectiveType: null == perspectiveType
          ? _value.perspectiveType
          : perspectiveType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _value.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      entityName: null == entityName
          ? _value.entityName
          : entityName // ignore: cast_nullable_to_non_nullable
              as String,
      totalReceivable: null == totalReceivable
          ? _value.totalReceivable
          : totalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      totalPayable: null == totalPayable
          ? _value.totalPayable
          : totalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      internalReceivable: null == internalReceivable
          ? _value.internalReceivable
          : internalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      internalPayable: null == internalPayable
          ? _value.internalPayable
          : internalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      internalNetPosition: null == internalNetPosition
          ? _value.internalNetPosition
          : internalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      externalReceivable: null == externalReceivable
          ? _value.externalReceivable
          : externalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      externalPayable: null == externalPayable
          ? _value.externalPayable
          : externalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      externalNetPosition: null == externalNetPosition
          ? _value.externalNetPosition
          : externalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      storeAggregates: null == storeAggregates
          ? _value.storeAggregates
          : storeAggregates // ignore: cast_nullable_to_non_nullable
              as List<StoreAggregate>,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
      collectionRate: null == collectionRate
          ? _value.collectionRate
          : collectionRate // ignore: cast_nullable_to_non_nullable
              as double,
      criticalCount: null == criticalCount
          ? _value.criticalCount
          : criticalCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PerspectiveSummaryImplCopyWith<$Res>
    implements $PerspectiveSummaryCopyWith<$Res> {
  factory _$$PerspectiveSummaryImplCopyWith(_$PerspectiveSummaryImpl value,
          $Res Function(_$PerspectiveSummaryImpl) then) =
      __$$PerspectiveSummaryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String perspectiveType,
      String entityId,
      String entityName,
      double totalReceivable,
      double totalPayable,
      double netPosition,
      double internalReceivable,
      double internalPayable,
      double internalNetPosition,
      double externalReceivable,
      double externalPayable,
      double externalNetPosition,
      List<StoreAggregate> storeAggregates,
      int counterpartyCount,
      int transactionCount,
      double collectionRate,
      int criticalCount});
}

/// @nodoc
class __$$PerspectiveSummaryImplCopyWithImpl<$Res>
    extends _$PerspectiveSummaryCopyWithImpl<$Res, _$PerspectiveSummaryImpl>
    implements _$$PerspectiveSummaryImplCopyWith<$Res> {
  __$$PerspectiveSummaryImplCopyWithImpl(_$PerspectiveSummaryImpl _value,
      $Res Function(_$PerspectiveSummaryImpl) _then)
      : super(_value, _then);

  /// Create a copy of PerspectiveSummary
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? perspectiveType = null,
    Object? entityId = null,
    Object? entityName = null,
    Object? totalReceivable = null,
    Object? totalPayable = null,
    Object? netPosition = null,
    Object? internalReceivable = null,
    Object? internalPayable = null,
    Object? internalNetPosition = null,
    Object? externalReceivable = null,
    Object? externalPayable = null,
    Object? externalNetPosition = null,
    Object? storeAggregates = null,
    Object? counterpartyCount = null,
    Object? transactionCount = null,
    Object? collectionRate = null,
    Object? criticalCount = null,
  }) {
    return _then(_$PerspectiveSummaryImpl(
      perspectiveType: null == perspectiveType
          ? _value.perspectiveType
          : perspectiveType // ignore: cast_nullable_to_non_nullable
              as String,
      entityId: null == entityId
          ? _value.entityId
          : entityId // ignore: cast_nullable_to_non_nullable
              as String,
      entityName: null == entityName
          ? _value.entityName
          : entityName // ignore: cast_nullable_to_non_nullable
              as String,
      totalReceivable: null == totalReceivable
          ? _value.totalReceivable
          : totalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      totalPayable: null == totalPayable
          ? _value.totalPayable
          : totalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      internalReceivable: null == internalReceivable
          ? _value.internalReceivable
          : internalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      internalPayable: null == internalPayable
          ? _value.internalPayable
          : internalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      internalNetPosition: null == internalNetPosition
          ? _value.internalNetPosition
          : internalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      externalReceivable: null == externalReceivable
          ? _value.externalReceivable
          : externalReceivable // ignore: cast_nullable_to_non_nullable
              as double,
      externalPayable: null == externalPayable
          ? _value.externalPayable
          : externalPayable // ignore: cast_nullable_to_non_nullable
              as double,
      externalNetPosition: null == externalNetPosition
          ? _value.externalNetPosition
          : externalNetPosition // ignore: cast_nullable_to_non_nullable
              as double,
      storeAggregates: null == storeAggregates
          ? _value._storeAggregates
          : storeAggregates // ignore: cast_nullable_to_non_nullable
              as List<StoreAggregate>,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      transactionCount: null == transactionCount
          ? _value.transactionCount
          : transactionCount // ignore: cast_nullable_to_non_nullable
              as int,
      collectionRate: null == collectionRate
          ? _value.collectionRate
          : collectionRate // ignore: cast_nullable_to_non_nullable
              as double,
      criticalCount: null == criticalCount
          ? _value.criticalCount
          : criticalCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PerspectiveSummaryImpl extends _PerspectiveSummary {
  const _$PerspectiveSummaryImpl(
      {required this.perspectiveType,
      required this.entityId,
      required this.entityName,
      required this.totalReceivable,
      required this.totalPayable,
      required this.netPosition,
      required this.internalReceivable,
      required this.internalPayable,
      required this.internalNetPosition,
      required this.externalReceivable,
      required this.externalPayable,
      required this.externalNetPosition,
      final List<StoreAggregate> storeAggregates = const [],
      required this.counterpartyCount,
      required this.transactionCount,
      required this.collectionRate,
      required this.criticalCount})
      : _storeAggregates = storeAggregates,
        super._();

  @override
  final String perspectiveType;
  @override
  final String entityId;
  @override
  final String entityName;
  @override
  final double totalReceivable;
  @override
  final double totalPayable;
  @override
  final double netPosition;
  @override
  final double internalReceivable;
  @override
  final double internalPayable;
  @override
  final double internalNetPosition;
  @override
  final double externalReceivable;
  @override
  final double externalPayable;
  @override
  final double externalNetPosition;
  final List<StoreAggregate> _storeAggregates;
  @override
  @JsonKey()
  List<StoreAggregate> get storeAggregates {
    if (_storeAggregates is EqualUnmodifiableListView) return _storeAggregates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_storeAggregates);
  }

  @override
  final int counterpartyCount;
  @override
  final int transactionCount;
  @override
  final double collectionRate;
  @override
  final int criticalCount;

  @override
  String toString() {
    return 'PerspectiveSummary(perspectiveType: $perspectiveType, entityId: $entityId, entityName: $entityName, totalReceivable: $totalReceivable, totalPayable: $totalPayable, netPosition: $netPosition, internalReceivable: $internalReceivable, internalPayable: $internalPayable, internalNetPosition: $internalNetPosition, externalReceivable: $externalReceivable, externalPayable: $externalPayable, externalNetPosition: $externalNetPosition, storeAggregates: $storeAggregates, counterpartyCount: $counterpartyCount, transactionCount: $transactionCount, collectionRate: $collectionRate, criticalCount: $criticalCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PerspectiveSummaryImpl &&
            (identical(other.perspectiveType, perspectiveType) ||
                other.perspectiveType == perspectiveType) &&
            (identical(other.entityId, entityId) ||
                other.entityId == entityId) &&
            (identical(other.entityName, entityName) ||
                other.entityName == entityName) &&
            (identical(other.totalReceivable, totalReceivable) ||
                other.totalReceivable == totalReceivable) &&
            (identical(other.totalPayable, totalPayable) ||
                other.totalPayable == totalPayable) &&
            (identical(other.netPosition, netPosition) ||
                other.netPosition == netPosition) &&
            (identical(other.internalReceivable, internalReceivable) ||
                other.internalReceivable == internalReceivable) &&
            (identical(other.internalPayable, internalPayable) ||
                other.internalPayable == internalPayable) &&
            (identical(other.internalNetPosition, internalNetPosition) ||
                other.internalNetPosition == internalNetPosition) &&
            (identical(other.externalReceivable, externalReceivable) ||
                other.externalReceivable == externalReceivable) &&
            (identical(other.externalPayable, externalPayable) ||
                other.externalPayable == externalPayable) &&
            (identical(other.externalNetPosition, externalNetPosition) ||
                other.externalNetPosition == externalNetPosition) &&
            const DeepCollectionEquality()
                .equals(other._storeAggregates, _storeAggregates) &&
            (identical(other.counterpartyCount, counterpartyCount) ||
                other.counterpartyCount == counterpartyCount) &&
            (identical(other.transactionCount, transactionCount) ||
                other.transactionCount == transactionCount) &&
            (identical(other.collectionRate, collectionRate) ||
                other.collectionRate == collectionRate) &&
            (identical(other.criticalCount, criticalCount) ||
                other.criticalCount == criticalCount));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      perspectiveType,
      entityId,
      entityName,
      totalReceivable,
      totalPayable,
      netPosition,
      internalReceivable,
      internalPayable,
      internalNetPosition,
      externalReceivable,
      externalPayable,
      externalNetPosition,
      const DeepCollectionEquality().hash(_storeAggregates),
      counterpartyCount,
      transactionCount,
      collectionRate,
      criticalCount);

  /// Create a copy of PerspectiveSummary
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PerspectiveSummaryImplCopyWith<_$PerspectiveSummaryImpl> get copyWith =>
      __$$PerspectiveSummaryImplCopyWithImpl<_$PerspectiveSummaryImpl>(
          this, _$identity);
}

abstract class _PerspectiveSummary extends PerspectiveSummary {
  const factory _PerspectiveSummary(
      {required final String perspectiveType,
      required final String entityId,
      required final String entityName,
      required final double totalReceivable,
      required final double totalPayable,
      required final double netPosition,
      required final double internalReceivable,
      required final double internalPayable,
      required final double internalNetPosition,
      required final double externalReceivable,
      required final double externalPayable,
      required final double externalNetPosition,
      final List<StoreAggregate> storeAggregates,
      required final int counterpartyCount,
      required final int transactionCount,
      required final double collectionRate,
      required final int criticalCount}) = _$PerspectiveSummaryImpl;
  const _PerspectiveSummary._() : super._();

  @override
  String get perspectiveType;
  @override
  String get entityId;
  @override
  String get entityName;
  @override
  double get totalReceivable;
  @override
  double get totalPayable;
  @override
  double get netPosition;
  @override
  double get internalReceivable;
  @override
  double get internalPayable;
  @override
  double get internalNetPosition;
  @override
  double get externalReceivable;
  @override
  double get externalPayable;
  @override
  double get externalNetPosition;
  @override
  List<StoreAggregate> get storeAggregates;
  @override
  int get counterpartyCount;
  @override
  int get transactionCount;
  @override
  double get collectionRate;
  @override
  int get criticalCount;

  /// Create a copy of PerspectiveSummary
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PerspectiveSummaryImplCopyWith<_$PerspectiveSummaryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StoreAggregate {
  String get storeId => throw _privateConstructorUsedError;
  String get storeName => throw _privateConstructorUsedError;
  double get receivable => throw _privateConstructorUsedError;
  double get payable => throw _privateConstructorUsedError;
  double get netPosition => throw _privateConstructorUsedError;
  int get counterpartyCount => throw _privateConstructorUsedError;
  bool get isHeadquarters => throw _privateConstructorUsedError;

  /// Create a copy of StoreAggregate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoreAggregateCopyWith<StoreAggregate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoreAggregateCopyWith<$Res> {
  factory $StoreAggregateCopyWith(
          StoreAggregate value, $Res Function(StoreAggregate) then) =
      _$StoreAggregateCopyWithImpl<$Res, StoreAggregate>;
  @useResult
  $Res call(
      {String storeId,
      String storeName,
      double receivable,
      double payable,
      double netPosition,
      int counterpartyCount,
      bool isHeadquarters});
}

/// @nodoc
class _$StoreAggregateCopyWithImpl<$Res, $Val extends StoreAggregate>
    implements $StoreAggregateCopyWith<$Res> {
  _$StoreAggregateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StoreAggregate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? storeId = null,
    Object? storeName = null,
    Object? receivable = null,
    Object? payable = null,
    Object? netPosition = null,
    Object? counterpartyCount = null,
    Object? isHeadquarters = null,
  }) {
    return _then(_value.copyWith(
      storeId: null == storeId
          ? _value.storeId
          : storeId // ignore: cast_nullable_to_non_nullable
              as String,
      storeName: null == storeName
          ? _value.storeName
          : storeName // ignore: cast_nullable_to_non_nullable
              as String,
      receivable: null == receivable
          ? _value.receivable
          : receivable // ignore: cast_nullable_to_non_nullable
              as double,
      payable: null == payable
          ? _value.payable
          : payable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      isHeadquarters: null == isHeadquarters
          ? _value.isHeadquarters
          : isHeadquarters // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StoreAggregateImplCopyWith<$Res>
    implements $StoreAggregateCopyWith<$Res> {
  factory _$$StoreAggregateImplCopyWith(_$StoreAggregateImpl value,
          $Res Function(_$StoreAggregateImpl) then) =
      __$$StoreAggregateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String storeId,
      String storeName,
      double receivable,
      double payable,
      double netPosition,
      int counterpartyCount,
      bool isHeadquarters});
}

/// @nodoc
class __$$StoreAggregateImplCopyWithImpl<$Res>
    extends _$StoreAggregateCopyWithImpl<$Res, _$StoreAggregateImpl>
    implements _$$StoreAggregateImplCopyWith<$Res> {
  __$$StoreAggregateImplCopyWithImpl(
      _$StoreAggregateImpl _value, $Res Function(_$StoreAggregateImpl) _then)
      : super(_value, _then);

  /// Create a copy of StoreAggregate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? storeId = null,
    Object? storeName = null,
    Object? receivable = null,
    Object? payable = null,
    Object? netPosition = null,
    Object? counterpartyCount = null,
    Object? isHeadquarters = null,
  }) {
    return _then(_$StoreAggregateImpl(
      storeId: null == storeId
          ? _value.storeId
          : storeId // ignore: cast_nullable_to_non_nullable
              as String,
      storeName: null == storeName
          ? _value.storeName
          : storeName // ignore: cast_nullable_to_non_nullable
              as String,
      receivable: null == receivable
          ? _value.receivable
          : receivable // ignore: cast_nullable_to_non_nullable
              as double,
      payable: null == payable
          ? _value.payable
          : payable // ignore: cast_nullable_to_non_nullable
              as double,
      netPosition: null == netPosition
          ? _value.netPosition
          : netPosition // ignore: cast_nullable_to_non_nullable
              as double,
      counterpartyCount: null == counterpartyCount
          ? _value.counterpartyCount
          : counterpartyCount // ignore: cast_nullable_to_non_nullable
              as int,
      isHeadquarters: null == isHeadquarters
          ? _value.isHeadquarters
          : isHeadquarters // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$StoreAggregateImpl extends _StoreAggregate {
  const _$StoreAggregateImpl(
      {required this.storeId,
      required this.storeName,
      required this.receivable,
      required this.payable,
      required this.netPosition,
      required this.counterpartyCount,
      required this.isHeadquarters})
      : super._();

  @override
  final String storeId;
  @override
  final String storeName;
  @override
  final double receivable;
  @override
  final double payable;
  @override
  final double netPosition;
  @override
  final int counterpartyCount;
  @override
  final bool isHeadquarters;

  @override
  String toString() {
    return 'StoreAggregate(storeId: $storeId, storeName: $storeName, receivable: $receivable, payable: $payable, netPosition: $netPosition, counterpartyCount: $counterpartyCount, isHeadquarters: $isHeadquarters)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoreAggregateImpl &&
            (identical(other.storeId, storeId) || other.storeId == storeId) &&
            (identical(other.storeName, storeName) ||
                other.storeName == storeName) &&
            (identical(other.receivable, receivable) ||
                other.receivable == receivable) &&
            (identical(other.payable, payable) || other.payable == payable) &&
            (identical(other.netPosition, netPosition) ||
                other.netPosition == netPosition) &&
            (identical(other.counterpartyCount, counterpartyCount) ||
                other.counterpartyCount == counterpartyCount) &&
            (identical(other.isHeadquarters, isHeadquarters) ||
                other.isHeadquarters == isHeadquarters));
  }

  @override
  int get hashCode => Object.hash(runtimeType, storeId, storeName, receivable,
      payable, netPosition, counterpartyCount, isHeadquarters);

  /// Create a copy of StoreAggregate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoreAggregateImplCopyWith<_$StoreAggregateImpl> get copyWith =>
      __$$StoreAggregateImplCopyWithImpl<_$StoreAggregateImpl>(
          this, _$identity);
}

abstract class _StoreAggregate extends StoreAggregate {
  const factory _StoreAggregate(
      {required final String storeId,
      required final String storeName,
      required final double receivable,
      required final double payable,
      required final double netPosition,
      required final int counterpartyCount,
      required final bool isHeadquarters}) = _$StoreAggregateImpl;
  const _StoreAggregate._() : super._();

  @override
  String get storeId;
  @override
  String get storeName;
  @override
  double get receivable;
  @override
  double get payable;
  @override
  double get netPosition;
  @override
  int get counterpartyCount;
  @override
  bool get isHeadquarters;

  /// Create a copy of StoreAggregate
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoreAggregateImplCopyWith<_$StoreAggregateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
