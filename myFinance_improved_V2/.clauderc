# MyFinance Flutter App - Project Guidelines

## Project Overview
**Name**: MyFinance (Toss-style financial management app)
**Framework**: Flutter 3.0+ with Riverpod state management
**Architecture**: Clean Architecture with feature-based structure
**Database**: Supabase (use Supabase MCP to check database schema)

---

## ğŸš¨ CRITICAL RULES - NEVER VIOLATE

### 1. Protected Folders (NEVER MODIFY WITHOUT EXPLICIT PERMISSION)

#### Rule: ALL domain/ and data/ folders are PROTECTED
```
âŒ NEVER touch ANY of these without asking first:

ğŸ“ Core Protected Folders:
   - lib/core/domain/
   - lib/core/data/

ğŸ“ Shared Protected Folders:
   - lib/shared/ (all files: widgets, themes, extensions, utils)

ğŸ“ Feature Protected Folders (domain/ and data/ in ALL features):
   - lib/features/*/domain/
   - lib/features/*/data/

Examples:
   âŒ lib/features/cash_location/domain/
   âŒ lib/features/cash_location/data/
   âŒ lib/features/attendance/domain/
   âŒ lib/features/attendance/data/
   âŒ lib/features/auth/domain/
   âŒ lib/features/auth/data/
   ... and ALL other feature domain/data folders
```

**Why Protected**:
- `domain/` contains business logic, entities, and use cases (core business rules)
- `data/` contains repositories, models, and data sources (data layer contracts)
- `shared/` contains cross-feature components (affects entire app)
- Changing these affects the entire architecture and multiple features

### 2. Confirmation Protocol (MANDATORY)

Before modifying ANY protected folder, use this format:

```
ğŸ”” PERMISSION REQUIRED

Protected files to modify:
  ğŸ“ lib/features/cash_location/domain/entities/location.dart
  ğŸ“ lib/shared/widgets/custom_button.dart

Current folder: lib/features/cash_location/
Reason: [Brief explanation of why these protected files need changes]

Impact:
  - [List affected features/components]

Alternatives considered:
  - [Option 1]
  - [Option 2]

âš ï¸ Awaiting your approval before proceeding...
```

### 3. Safe Zones (Can Modify Freely)

Within your current feature folder, you CAN modify:
```
âœ… lib/features/[current_feature]/presentation/
   - screens/
   - widgets/
   - notifiers/
   - utils/ (feature-specific utils)

Example: Working on cash_location
âœ… lib/features/cash_location/presentation/screens/
âœ… lib/features/cash_location/presentation/widgets/
âœ… lib/features/cash_location/presentation/notifiers/

âŒ lib/features/cash_location/domain/
âŒ lib/features/cash_location/data/
```

### 4. Database Changes (Use Supabase MCP)

Before making database-related changes:
```
1. Use Supabase MCP to check current schema
2. Verify table structures and relationships
3. Ask permission before modifying:
   - Data models in data/ folders
   - Repository interfaces in domain/ folders
   - Database queries in data sources
```

---

## ğŸ—ï¸ Architecture Integrity

### Clean Architecture Layers (STRICTLY ENFORCED)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation Layer (âœ… Safe to modify)         â”‚
â”‚  - Screens, Widgets, Notifiers                  â”‚
â”‚  - User interaction and UI logic                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ depends on
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Domain Layer (ğŸ”’ PROTECTED - Ask first)        â”‚
â”‚  - Entities, Use Cases, Repository Interfaces   â”‚
â”‚  - Pure business logic (no Flutter/UI)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†‘ implemented by
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Data Layer (ğŸ”’ PROTECTED - Ask first)          â”‚
â”‚  - Repository Implementations                    â”‚
â”‚  - Data Sources (Remote, Local)                 â”‚
â”‚  - Models (DTO, Mappers)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Dependency Rule (NEVER VIOLATE)
```
âœ… Presentation â†’ Domain (allowed)
âœ… Data â†’ Domain (allowed)
âŒ Domain â†’ Presentation (forbidden)
âŒ Domain â†’ Data (forbidden)
âŒ Presentation â†’ Data (forbidden - must go through Domain)
```

### Feature Structure Template
```
lib/features/[feature_name]/
â”œâ”€â”€ domain/ (ğŸ”’ PROTECTED)
â”‚   â”œâ”€â”€ entities/          # Business objects
â”‚   â”œâ”€â”€ repositories/      # Abstract interfaces
â”‚   â””â”€â”€ usecases/         # Business logic
â”‚
â”œâ”€â”€ data/ (ğŸ”’ PROTECTED)
â”‚   â”œâ”€â”€ models/           # DTOs and mappers
â”‚   â”œâ”€â”€ repositories/     # Concrete implementations
â”‚   â””â”€â”€ datasources/      # API, local storage
â”‚
â””â”€â”€ presentation/ (âœ… SAFE ZONE)
    â”œâ”€â”€ screens/          # Full page screens
    â”œâ”€â”€ widgets/          # Feature-specific widgets
    â”œâ”€â”€ notifiers/        # State management
    â””â”€â”€ utils/           # Feature-specific helpers
```

---

## ğŸš« Anti-Over-Engineering Rules

### The Goldilocks Principle
```
âŒ Too Little:
   - No error handling
   - Skipping null safety
   - Hardcoded values everywhere
   - No state management

âœ… Just Right:
   - Clear, readable code
   - Appropriate abstractions
   - Error handling for expected cases
   - Simple solutions that work

âŒ Too Much:
   - Abstraction for single use
   - Complex patterns for simple problems
   - Premature optimization
   - Over-generalization
```

### When to Add Abstraction
```
âœ… Add abstraction when:
   - Used in 3+ places (Rule of Three)
   - Clear variation points exist
   - Testing requires it
   - Business logic is complex

âŒ Don't add abstraction when:
   - Used only once or twice
   - Requirements unclear
   - Simple implementation works
   - "Maybe we'll need it later"
```

### YAGNI (You Aren't Gonna Need It)
```
âŒ Don't build:
   - Features for "future requirements"
   - Flexibility without clear use case
   - Abstractions "just in case"
   - Complex solutions for simple problems

âœ… Do build:
   - What's needed NOW
   - What solves the CURRENT problem
   - What makes code MAINTAINABLE today
   - What REQUIREMENTS specify
```

---

## ğŸ“ Naming Conventions (STRICTLY ENFORCED)

### Golden Rules
1. **NO ABBREVIATIONS** (except ID, URL, API, HTTP, JSON)
2. **BE EXPLICIT** - Full words, clear intent
3. **BE CONSISTENT** - Follow existing patterns
4. **BE CONTEXTUAL** - Use context to avoid redundancy

### File Naming (snake_case)
```dart
// âœ… CORRECT - Clear, descriptive, lowercase with underscores
transaction_list_screen.dart
account_repository.dart
cash_ending_state_notifier.dart
custom_elevated_button.dart
date_time_formatter_util.dart

// âŒ WRONG - Abbreviations, unclear, wrong case
TxListScreen.dart          // Wrong: PascalCase for files
acc_repo.dart             // Wrong: Abbreviation
cash_end_notif.dart       // Wrong: Abbreviation
custom_btn.dart           // Wrong: Abbreviation
dt_fmt_util.dart          // Wrong: Too abbreviated
```

### Class Naming (PascalCase)
```dart
// âœ… CORRECT - Clear purpose, full words
class TransactionListScreen extends ConsumerWidget {}
class AccountRepository implements AccountRepositoryInterface {}
class CashEndingStateNotifier extends StateNotifier {}
class CustomElevatedButton extends StatelessWidget {}
class DateTimeFormatterUtil {}

// âŒ WRONG - Abbreviated, unclear
class TxListScr extends ConsumerWidget {}
class AccRepo implements IAccRepo {}
class CashEndNotif extends StateNotifier {}
class CustBtn extends StatelessWidget {}
class DTFmtUtil {}
```

### Variable Naming (camelCase)
```dart
// âœ… CORRECT - Self-documenting, clear type
final List<Transaction> transactionList = [];
final double accountBalance = 1000.0;
final bool isLoadingTransactions = false;
final String selectedTransactionId = 'tx_123';
final DateTime transactionCreatedDate = DateTime.now();
final int maximumTransactionAmount = 10000;

// âŒ WRONG - Abbreviated, unclear
final List<Transaction> txList = [];
final double accBal = 1000.0;
final bool isLoading = false;  // Loading what?
final String selTxId = 'tx_123';
final DateTime txDate = DateTime.now();
final int maxTxAmt = 10000;
```

### Function/Method Naming (camelCase, verb-first)
```dart
// âœ… CORRECT - Action verb + clear object
Future<List<Transaction>> fetchTransactionsByDateRange(DateTime start, DateTime end) async {}
Future<void> updateAccountBalance(String accountId, double amount) async {}
bool validateTransactionAmount(double amount) {}
String formatCurrencyAmount(double amount, String currencyCode) {}
void deleteTransactionById(String transactionId) {}
Future<Account> getAccountById(String accountId) async {}

// âŒ WRONG - Abbreviated, unclear action
Future<List<Transaction>> getTxDate(DateTime start, DateTime end) async {}
Future<void> updAccBal(String id, double amt) async {}
bool valTxAmt(double amt) {}
String fmtCur(double amt, String code) {}
void delTx(String id) {}
Future<Account> getAcc(String id) async {}
```

### Constants (SCREAMING_SNAKE_CASE)
```dart
// âœ… CORRECT - All caps with underscores
const double DEFAULT_TRANSACTION_AMOUNT = 0.0;
const String API_BASE_URL = 'https://api.example.com';
const int MAXIMUM_RETRY_ATTEMPTS = 3;
const Duration TRANSACTION_TIMEOUT_DURATION = Duration(seconds: 30);

// âŒ WRONG - Wrong case, abbreviated
const double defaultTxAmount = 0.0;
const String apiUrl = 'https://api.example.com';
const int maxRetry = 3;
const Duration txTimeout = Duration(seconds: 30);
```

### Private Members (leading underscore)
```dart
// âœ… CORRECT - Private with clear names
class TransactionService {
  final TransactionRepository _transactionRepository;
  final Logger _logger;

  Future<void> _validateTransactionAmount(double amount) async {}
  String _formatTransactionDescription(String description) {}
}

// âŒ WRONG - Abbreviated private members
class TransactionService {
  final TransactionRepository _txRepo;
  final Logger _log;

  Future<void> _valTxAmt(double amt) async {}
  String _fmtTxDesc(String desc) {}
}
```

### Naming by Context
```dart
// âœ… CORRECT - Use context to avoid redundancy
class Transaction {
  final String id;              // Not transactionId
  final double amount;          // Not transactionAmount
  final DateTime createdDate;   // Not transactionCreatedDate
}

class TransactionRepository {
  Future<Transaction> getById(String id) {}        // Not getTransactionById
  Future<List<Transaction>> getAll() {}            // Not getAllTransactions
  Future<void> update(Transaction transaction) {}  // Not updateTransaction
}

// âŒ WRONG - Redundant names
class Transaction {
  final String transactionId;           // Redundant
  final double transactionAmount;       // Redundant
  final DateTime transactionCreatedDate; // Redundant
}
```

### Acceptable Abbreviations (ONLY THESE)
```
âœ… Allowed:
   - id, ID (identifier)
   - url, URL (uniform resource locator)
   - api, API (application programming interface)
   - http, HTTP (hypertext transfer protocol)
   - json, JSON (javascript object notation)
   - dto, DTO (data transfer object)
   - uuid, UUID (universally unique identifier)

âŒ Not Allowed:
   - tx (transaction)
   - acc (account)
   - amt (amount)
   - desc (description)
   - msg (message)
   - btn (button)
   - fmt (format)
   - val (validate/value)
   - temp (temporary)
   - config (configuration) - use "configuration"
   - info (information) - use "information"
```

### Naming Checklist
Before committing code, verify:
```
â–¡ No abbreviations (except allowed list)
â–¡ Full descriptive words used
â–¡ Consistent with existing codebase
â–¡ Self-documenting (no need for comments to understand)
â–¡ Proper case (snake_case for files, PascalCase for classes, camelCase for variables)
â–¡ Clear action verbs for functions
â–¡ Contextually appropriate (no redundancy)
```

---

## ğŸ¯ State Management (Riverpod)

### Provider Best Practices
```dart
// âœ… CORRECT - Use code generation with @riverpod
@riverpod
class TransactionNotifier extends _$TransactionNotifier {
  @override
  Future<List<Transaction>> build() async {
    return await _fetchTransactions();
  }

  Future<void> addTransaction(Transaction transaction) async {
    // Implementation
  }
}

// âœ… CORRECT - Family providers for parameters
@riverpod
class AccountNotifier extends _$AccountNotifier {
  @override
  Future<Account> build(String accountId) async {
    return await _fetchAccount(accountId);
  }
}

// âŒ WRONG - Manual provider (legacy)
final transactionProvider = StateNotifierProvider<TransactionNotifier, AsyncValue<List<Transaction>>>((ref) {
  return TransactionNotifier();
});
```

---

## ğŸ§ª Testing Guidelines

### What to Test
```
âœ… Must Test:
   - Business logic in use cases
   - Repository implementations
   - Complex calculations
   - Data transformations
   - Error scenarios

âš ï¸ Optional:
   - Simple getters/setters
   - UI widgets (unless complex)
   - Third-party library wrappers

âŒ Don't Test:
   - Framework code
   - Third-party packages
   - Generated code
```

### Test Naming
```dart
// âœ… CORRECT - Clear description of behavior
void main() {
  group('TransactionRepository', () {
    test('fetchTransactions returns list when successful', () {});
    test('fetchTransactions throws NetworkException when network fails', () {});
    test('createTransaction saves to database and returns transaction', () {});
  });
}

// âŒ WRONG - Unclear test names
void main() {
  group('TxRepo', () {
    test('test1', () {});
    test('fails', () {});
    test('create', () {});
  });
}
```

---

## âš ï¸ Error Handling

### Standard Pattern (Either from dartz)
```dart
// âœ… CORRECT - Use Either for error handling
Future<Either<Failure, List<Transaction>>> fetchTransactions() async {
  try {
    final transactions = await _remoteDataSource.getTransactions();
    return Right(transactions);
  } on NetworkException catch (error) {
    return Left(NetworkFailure(message: error.message));
  } on AuthException catch (error) {
    return Left(AuthFailure(message: error.message));
  } catch (error) {
    return Left(UnexpectedFailure(message: error.toString()));
  }
}

// âŒ WRONG - Throwing exceptions up the stack
Future<List<Transaction>> fetchTransactions() async {
  return await _remoteDataSource.getTransactions(); // Unhandled errors
}
```

---

## ğŸ“š Documentation Rules

### When to Document
```
âœ… Always Document:
   - Public API methods
   - Complex business logic
   - Non-obvious implementations
   - Workarounds or hacks
   - Architecture decisions

âŒ Don't Document:
   - Self-explanatory code
   - Simple getters/setters
   - Obvious implementations
```

### Documentation Format
```dart
/// Fetches transactions within the specified date range.
///
/// Returns a list of [Transaction] objects sorted by date (newest first).
///
/// Throws:
/// - [NetworkException] if the network request fails
/// - [AuthException] if the user is not authenticated
/// - [ValidationException] if date range is invalid
///
/// Example:
/// ```dart
/// final transactions = await repository.fetchTransactions(
///   startDate: DateTime(2024, 1, 1),
///   endDate: DateTime(2024, 1, 31),
/// );
/// ```
Future<Either<Failure, List<Transaction>>> fetchTransactions({
  required DateTime startDate,
  required DateTime endDate,
}) async {
  // Implementation
}
```

---

## ğŸš€ Performance Best Practices

### Do's
```
âœ… Use const constructors where possible
âœ… Implement dispose() for controllers and streams
âœ… Use ListView.builder for long lists
âœ… Cache network images with cached_network_image
âœ… Use AutoDispose for Riverpod providers when appropriate
âœ… Lazy load data when possible
âœ… Use Keys for widget optimization
```

### Don'ts
```
âŒ Build widgets in tight loops
âŒ Create providers inside build methods
âŒ Ignore memory leaks
âŒ Skip lazy loading for large datasets
âŒ Rebuild entire widget tree unnecessarily
```

---

## ğŸ—‚ï¸ Database (Supabase)

### Before Database Changes
```
1. Check current schema using Supabase MCP
2. Verify table relationships
3. Ask permission before modifying:
   - Models in lib/features/*/data/models/
   - Repository interfaces in lib/features/*/domain/repositories/
   - Data sources in lib/features/*/data/datasources/
```

### Supabase MCP Usage
```
Use Supabase MCP to:
  - Query current table schema
  - Check column types and constraints
  - Verify foreign key relationships
  - Review RLS (Row Level Security) policies
```

---

## ğŸ”§ Development Workflow

### Before Starting Work
```
1. âœ… Identify the feature you're working on
2. âœ… Understand the scope (presentation only? needs domain/data?)
3. âœ… Check if protected folders are involved
4. âš ï¸ If yes â†’ ASK FOR PERMISSION first
5. âœ… Review existing patterns in similar features
6. âœ… Plan changes within safe zones
```

### During Development
```
1. âœ… Stay within presentation/ folder when possible
2. âœ… Follow existing patterns and conventions
3. âœ… Use clear, descriptive names (no abbreviations)
4. âœ… Keep it simple (avoid over-engineering)
5. âš ï¸ If need to touch domain/data â†’ STOP and ASK
6. âœ… Write self-documenting code
7. âœ… Add tests for new business logic
```

### Before Committing
```
1. âœ… Run flutter analyze
2. âœ… Run flutter test
3. âœ… Review naming conventions (no abbreviations!)
4. âœ… Verify no changes to protected folders without permission
5. âœ… Check architecture integrity maintained
6. âœ… Ensure no over-engineering
```

---

## ğŸ“‹ Pre-Change Checklist

Use this before proposing ANY changes:

```
â–¡ Changes scoped to current feature's presentation/ folder?
â–¡ No modifications to ANY domain/ folders?
â–¡ No modifications to ANY data/ folders?
â–¡ No modifications to lib/shared/ without permission?
â–¡ All names use full words (no abbreviations)?
â–¡ Naming conventions followed (snake_case files, PascalCase classes)?
â–¡ Architecture integrity maintained?
â–¡ Not over-engineered (YAGNI applied)?
â–¡ Error handling implemented properly?
â–¡ Tests written for business logic?
â–¡ Documentation added where needed?
â–¡ Supabase MCP checked for database schema (if applicable)?
```

---

## ğŸ¤ Communication Templates

### Template 1: Permission for Protected Folders
```
ğŸ”” PERMISSION REQUIRED

Protected files affected:
  ğŸ“ lib/features/cash_location/domain/entities/location.dart
  ğŸ“ lib/features/cash_location/data/repositories/location_repository_impl.dart

Current working folder: lib/features/cash_location/presentation/

Reason: Need to add [new field] to Location entity for [feature requirement]

Impact:
  - Will affect: [list affected features/screens]
  - Database changes: [yes/no, details]
  - Breaking changes: [yes/no]

Alternatives considered:
  1. [Alternative approach 1]
  2. [Alternative approach 2]

Recommended approach: [Your recommendation]

âš ï¸ Awaiting your approval before proceeding...
```

### Template 2: Database Schema Check
```
ğŸ” DATABASE SCHEMA CHECK NEEDED

Using Supabase MCP to verify:
  - Table: [table_name]
  - Columns needed: [list]
  - Relationships: [foreign keys, if applicable]

Before proceeding with changes to:
  ğŸ“ lib/features/[feature]/data/models/[model].dart
  ğŸ“ lib/features/[feature]/domain/entities/[entity].dart

âš ï¸ Will share findings and ask for approval...
```

### Template 3: Shared Component Modification
```
ğŸ”” SHARED COMPONENT CHANGE REQUEST

File: lib/shared/[component_path]
Current usage: Used by [X] features/screens

Proposed change: [Brief description]

Reason: [Why this is needed]

Impact analysis:
  âœ… No breaking changes expected
  OR
  âš ï¸ May affect: [list features]

Testing plan:
  - [Test scenario 1]
  - [Test scenario 2]

Proceed? âš ï¸
```

---

## ğŸ¯ Summary - Three Golden Rules

### 1. ğŸ”’ ASK FIRST
```
Before touching:
  âŒ ANY domain/ folder (at any level)
  âŒ ANY data/ folder (at any level)
  âŒ ANY file in lib/shared/
  âŒ ANY database-related changes

Always ask permission and explain:
  - What you need to change
  - Why it's necessary
  - What the impact will be
  - What alternatives exist
```

### 2. ğŸ“ NAME CLEARLY
```
No abbreviations (except ID, URL, API, HTTP, JSON)
  âœ… transactionList (not txList)
  âœ… accountBalance (not accBal)
  âœ… isLoadingTransactions (not isLoading)

Full descriptive words
  âœ… fetchTransactionsByDateRange()
  âœ… updateAccountBalance()
  âœ… validateTransactionAmount()

Follow conventions
  - Files: snake_case.dart
  - Classes: PascalCase
  - Variables/Functions: camelCase
  - Constants: SCREAMING_SNAKE_CASE
```

### 3. âš–ï¸ ENGINEER RIGHT
```
Not too little:
  âŒ Skip error handling
  âŒ Ignore null safety
  âŒ No state management

Just right:
  âœ… Clear, maintainable code
  âœ… Appropriate error handling
  âœ… Simple solutions that work
  âœ… Follow existing patterns

Not too much:
  âŒ Premature optimization
  âŒ Abstraction for single use
  âŒ "Maybe we'll need it later"
  âŒ Over-generalization
```

---

## ğŸ“ When in Doubt

```
1. â“ Am I touching domain/ or data/? â†’ ASK FIRST
2. â“ Am I modifying lib/shared/? â†’ ASK FIRST
3. â“ Am I using abbreviations? â†’ USE FULL WORDS
4. â“ Am I over-engineering? â†’ KEEP IT SIMPLE
5. â“ Does this follow existing patterns? â†’ CHECK CODEBASE
6. â“ Is this maintainable? â†’ READ IT LIKE A STORY
7. â“ Does this break architecture? â†’ REVIEW LAYERS
8. â“ Database changes needed? â†’ USE SUPABASE MCP
```

**When still unsure â†’ ASK THE USER**

---

*This configuration ensures clean, maintainable, scalable code while protecting critical architecture layers and respecting project boundaries. Every change maintains architectural integrity without over-engineering.*
