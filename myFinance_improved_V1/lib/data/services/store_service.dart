import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

// Store service provider
final storeServiceProvider = Provider<StoreService>((ref) {
  return StoreService();
});

class StoreService {
  final _supabase = Supabase.instance.client;

  /// Create a new store with all available fields
  /// Store code is automatically generated by the database
  Future<Map<String, dynamic>?> createStore({
    required String storeName,
    required String companyId,
    String? storeAddress,
    String? storePhone,
    int? huddleTime,
    int? paymentTime,
    int? allowedDistance,
  }) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) {
        throw Exception('No user logged in');
      }

      // Prepare store data
      final storeData = <String, dynamic>{
        'store_name': storeName,
        'company_id': companyId,
        'store_address': storeAddress ?? '',
        'store_phone': storePhone ?? '',
      };

      // Add optional operational settings if provided
      if (huddleTime != null) {
        storeData['huddle_time'] = huddleTime;
      }
      if (paymentTime != null) {
        storeData['payment_time'] = paymentTime;
      }
      if (allowedDistance != null) {
        storeData['allowed_distance'] = allowedDistance;
      }

      // Create the store - store_code will be auto-generated by database
      final storeResponse = await _supabase
          .from('stores')
          .insert(storeData)
          .select('store_id, store_code, store_name')
          .single();

      // The database trigger will automatically create user_stores entry
      // Return the store details including the auto-generated store_code
      return storeResponse;
    } catch (e) {
      return null;
    }
  }

  /// Get all stores for a company
  Future<List<Map<String, dynamic>>> getCompanyStores(String companyId) async {
    try {
      final response = await _supabase
          .from('stores')
          .select('*')
          .eq('company_id', companyId)
          .eq('is_deleted', false)
          .order('created_at', ascending: false);

      return List<Map<String, dynamic>>.from(response);
    } catch (e) {
      return [];
    }
  }

  /// Update store information
  Future<bool> updateStore({
    required String storeId,
    String? storeName,
    String? storeAddress,
    String? storePhone,
    int? huddleTime,
    int? paymentTime,
    int? allowedDistance,
  }) async {
    try {
      final updateData = <String, dynamic>{};

      if (storeName != null) updateData['store_name'] = storeName;
      if (storeAddress != null) updateData['store_address'] = storeAddress;
      if (storePhone != null) updateData['store_phone'] = storePhone;
      if (huddleTime != null) updateData['huddle_time'] = huddleTime;
      if (paymentTime != null) updateData['payment_time'] = paymentTime;
      if (allowedDistance != null) updateData['allowed_distance'] = allowedDistance;

      if (updateData.isEmpty) {
        return true; // Nothing to update
      }

      updateData['updated_at'] = DateTime.now().toIso8601String();

      await _supabase
          .from('stores')
          .update(updateData)
          .eq('store_id', storeId);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Soft delete a store
  Future<bool> deleteStore(String storeId) async {
    try {
      await _supabase
          .from('stores')
          .update({
            'is_deleted': true,
            'deleted_at': DateTime.now().toIso8601String(),
          })
          .eq('store_id', storeId);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Get store details by ID
  Future<Map<String, dynamic>?> getStoreById(String storeId) async {
    try {
      final response = await _supabase
          .from('stores')
          .select('*')
          .eq('store_id', storeId)
          .eq('is_deleted', false)
          .single();

      return response;
    } catch (e) {
      return null;
    }
  }

  /// Check if user has access to a store
  Future<bool> userHasStoreAccess(String storeId) async {
    try {
      final userId = _supabase.auth.currentUser?.id;
      if (userId == null) return false;

      final response = await _supabase
          .from('user_stores')
          .select('user_store_id')
          .eq('user_id', userId)
          .eq('store_id', storeId)
          .eq('is_deleted', false)
          .maybeSingle();

      return response != null;
    } catch (e) {
      return false;
    }
  }
}